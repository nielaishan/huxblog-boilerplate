---
layout:   post
title:    "操作系统"
subtitle: "进程、内存管理"
date:     2017-07-07
author:   "NL"
header-img: "img/post-bg-2015.jpg"
tags:
    - 操作系统
---

## 进程

### 进程管理

1. 就绪状态得到CPU，通过进程调度，变为执行态；执行状态等待I/O请求，变为阻塞态；或者执行结束；阻塞状态得到I／O，变为就绪状态；执行态由于时间片完，变为就绪态。

2. 上下文切换：将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态。

3. 进程通信：1. 共享内存（生产者与消费者模型），2. 消息传递

4. 线程：一种CPU利用的基本单元。它由线程ID、程序计数器、寄存器集合和栈组成。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源

5. 线程池：在进程开始时创建一定数量的线程，并放入池中。

   >线程池的主要优点：
   >
   >1. 通常用现有线程处理请求要比等待新的线程要快。
   >2. 线程池限制了在任何时候可用线程的数量。(线程的数量：由系统CPU的数量、物理内存的大小和并发客户请求的期望值因素决定)。

6. Pthread 信号量实现生产者与消费者



   ```c++
#include<stdio.h>
#include<pthread.h>
#include<semaphore.h>
#include<apue.h>
int ring[64];
sem_t semBlack;
sem_t semData;


void *product(void *arg) {
	int step = 0;
	while (1) {
		sem_wait(&semBlack);
		int data = rand()%1234;
		ring[step] = data;
		step++;
		step%=64;
		printf("produce done: %d\n", data);
		sem_post(&semData);
	}
}

void *consume(void *arg) {
	int step = 0;
	while (1) {
		sem_wait(&semData);   // 信号量减一， 信号量为0是函数阻塞
		int data = ring[step];
		step++;
		step %= 64;
		printf("consume done: %d\n", data);
		sem_post(&semBlack);  //信号量加一
	}
}

int main() {
	sem_init(&semBlack, 0, 64);                       //此处初始信号量为64。empty
	sem_init(&semData, 0, 0);						  //此处为0。           full

	pthread_t consumer, producter;

	pthread_create(&consumer, NULL, consume, NULL);   //线程创建
	pthread_create(&producter, NULL, product, NULL);

	pthread_join(consumer, NULL);                     //等待线程结束
	pthread_join(producter, NULL);					

	sem_destroy(&semBlack);   
	sem_destroy(&semData);
	return 0;
}

   ```

### CPU调度

1. 吞吐量：一个时间单元内所完成进程的数量。

2. 调度算法：

   > 1. 先到先服务调度（FCFS）：非抢占；
   > 2. 最短作业优先调度算法（SJF）：抢占或非抢占；
   > 3. 优先调度算法：抢占或非抢占，主要问题是：无穷阻塞
   > 4. 轮转算法：定义时间片，为每个进程分配不超过一个时间片的CPU。
   > 5. 多级队列调度；
   > 6. 多级反馈队列调度；

### 死锁

1. 必要条件：互斥；占有并等待；非抢占；循环等待。同时满足会引起死锁。

2. 若资源分配图有环，产生死锁。

3. 死锁避免：银行家算法：

   > 安全状态：如果对于每个Pi，Pi仍然是还可以申请的资源数小于当前可用资源加上Pj（j<i）所占的资源。
   >
   > 1. 如果request[i] <= Need[i], 转2步，产生出错，已超过了其最大请求
   >
   > 2. 如果request[i] <= available[i]，转3步，否则必须等待，没有资源。
   >
   > 3. available[i] = available[i]-requestr[i];
   >
   >    allocation[i] = allocation[i]+request[i];
   >
   >    Need[i] = Need[i]-request[i];

4. 死锁检测

5. 死锁恢复

   > 1. 简单地终止一个或多个进程以打破循环等待。
   > 2. 一个或多个进程那里抢占一个或多个资源。

### 内存管理

1. 高速缓存：解决CPU与内存之间的速度差异，增加高速内存。

2. 逻辑地址：CPU所生成的地址；物理地址：内存单元所看到的地址。从逻辑地址到物理地址的映射是由内存管理单元的硬件设备完成的。

3. 动态存储分配问题

   > 首次适应：分配第一个足够大的孔。查询可以从头开始。一旦找到足够大的空闲孔，就可以停止。
   >
   > 最佳适应：分配最小的足够大的孔。必须查找整个列表，按大小排序。
   >
   > 最差适应：分配最大的孔。必须查找整个列表，大小排序。

4. 分页内存管理（碎片）

   > 1. 分页避免了将不同大小的内存块匹配到交换空间上这样的麻烦。
   > 2. 物理内存分为固定大小的块：称为帧。而将逻辑内存也分为同样大小的块，称为页。当需要执行进程是，其页从备份存储中调入到可用的内存帧中。
   > 3. 由CPU生成的每个地址分为两个部分：页号与页偏移。页号作为页表的索引。页表包含每页所在的物理内存的基地址。这些基地址与页偏移的组合就形成了物理地址。
   > 4. 页大小通常为2的幂。如果逻辑地址空间$2^m$,且页大小为$2^n$,那么逻辑地址的高$m-n$位表示页号，而低n位表示页偏移。

5. 分段内存管理

   > 1. 引入分段存储管理方式：1、由于通常的程序都可分为若干段，如主程序段、子程序段、数据段及栈段，每个段大多是一个相对独立的逻辑单位。2、实现和满足信息共享、信息保护、动态链接。

### 虚拟内存

> 虚拟内存将逻辑内存和物理内存分开。
>
> 虚拟存储器：是指具有请求调入和置换功能，能从逻辑上对内存容量加以扩充的一种存储器。
>
> 特征：多次性、对换性、虚拟性。

1. 先进先出（FIFO）页面置换算法

   > 当必须置换一页时，将选择最旧的页。

2. 最佳（Optimal）置换算法

   > 页错误率最低的。且没有Belady异常：对有的页置换算法，页错误率可能会随着所分配的帧数的增加而增加。
   >
   > 其所选择的被淘汰页面时以后永不使用的，或许是在最长的时间内不再访问的页面。

3. 最近最少使用算法（LRU）

   >选择最近最久未被访问的页。

### 分布式系统

1. 分布式系统：通过通信网络而松散连接的一组处理器的集合。
2. 建立分布式系统的原因：资源共享、加快计算速度、可靠性、通信。
3. 分布式操作系统的类型：网络操作系统。