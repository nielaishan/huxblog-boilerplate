---
layout:   post
title:    "C++面试"
subtitle: "在路上，，，"
date:     2017-08-26
author:   "NL"
header-img: "img/post-bg-2015.jpg"
tags:
    - offer
---

###C++

1. 头文件中#ifndef的作用

   >在头文件中加入#ifndef或#ifdef等宏定义，是为了防止重复声明。
   >
   >​        我们知道，头文件一般是用来声明的，会被其他的源文件和头文件include，当被多个文件include的时候就会造成重复声明。 为了使得只声明一次，引入前面所说的宏定义，一般以文件名大写和_来当宏的名字。
   >
   >​        这个宏是给预处理器用的，通常预处理变量用大写，所以这些宏定义都用大写。为了方便，一般将大写的文件名作为预处理器变量，其实在#ifndef后面加什么都都可以，用文件名只是为了好区分。它只是用来定义一个预处理器变量。
   >
   >举个例子：
   >
   >在example.h头文件中定义
   >
   >\#ifndef WHAT
   >
   >\#define WHAT
   >
   >\#endif
   >
   >这样，就保证example.h在给定的源文件中只处理一次。我们首先检测 #ifndef第一次处理头文件时，[测试](http://lib.csdn.net/base/softwaretest)会成功，因为 WHAT 还未定义。下一条语句定义了 WHAT。那样的话，如果我们编译的文件恰好又一次包含了该头文件。#ifndef 指示会发现 WHAT 已经定义，并且忽略该头文件的剩余部分。
   >
   >其中WHAT可以随意写，一般按文件名写成EXAMPLE_H

2. [C++面试](http://blog.csdn.net/hmxz2nn/article/details/53152598).

3. [C++11新特性](http://www.cnblogs.com/pzhfei/archive/2013/03/02/CPP_new_feature.html).[link](http://blog.csdn.net/yapian8/article/details/42341351)

   > 1. 智能指针：一个栈对象，并非是指针对象,[link](http://blog.csdn.net/xt_xiaotian/article/details/5714477).
   >    1. unique_ptr：当一块内存的所有权并不是共享的时候（它并不具有拷贝构造函数），可以使用，但是，它可以被转换为另外一个`unique_ptr`（具有移动构造函数）。
   >    2. shared_ptr：当一块内存的所有权可以被共享的时候，可以使用（这就是为什么它叫这个名）
   >    3. weak_ptr：具有一个shared_ptr管理的指向一个实体对象的引用，但是并没有做任何引用计数的工作，它被用来打破循环引用关系（想象一个关系树，父节点拥有指向子节点的引用`（shared_ptr）`，但是子节点也必须持有指向父节点的引用；如果第二个引用也是一个独立的引用，一个循环就产生了，这会导致任何对象都永远无法释放）。
   >    4. `auto_ptr`已经过时了，应该不再被使用了，转移所有权
   >    5. `make_shared`是一个非成员函数，具有给共享对象分配内存，并且只分配一次内存的优点，和显式通过构造函数初始化的`shared_ptr`相比较，后者需要至少两次分配内存。这些额外的开销有可能会导致内存溢出的问题，在下一个例子中，如果`seed()`抛出一个异常，则表示发生了内存溢出。
   >    6. 如果使用`make_shared`，则可以避开类似问题。第三个例子展示了`weak_ptr`的用法，注意，你必须通过调用`lock()`来获取`shared_ptr`中指向对象的引用，以此来访问对象。
   > 2. auto
   > 3. constexpr
   >    1. const并未区分出编译期常量和运行期常量
   >       constexpr限定在了编译期常量
   > 4. final、override
   > 5. 限定作用域的枚举类型：它永远不会在代码域中抛出枚举成员，也不会隐式的转换为整形，同时还可以具有用户指定的底层类型（这个特征也被加入了传统枚举类型中）。
   > 6. Lambda:匿名函数：匿名的方法，也叫做`lambda`表达式，被加进了`C++11`标准里，并且立刻得到了开发者们的重视。这是一个从函数式语言中借鉴来的，非常强大的特征，它让一些其他的特征和强大的库得以实现。在任何函数对象、函数、`std::function`中出现的地方，你都可以用`lambda`表达式:
   > 7. 标准库的begin()和end()：提升了语言的标准性和一致性，也使更多的泛型编程变成了可能，它们和所有的`STL`容器都是兼容的，但却不仅仅是简单的重载，因此你可以随意扩展`begin()`和`end()`，以便兼容任何类型，针对`C`类型数组的重载也一样是支持的
   > 8. `static_assert`宏和类型萃取器：
   >    1. `static_assert`会执行一个编译器的的断言，如果断言为真，什么都不会发生，如果断言为假，编译器则会显示一些特定的错误信息。
   >    2. 当和类型萃取一起使用的时候，`static_assert`会变得更加有用，这些是一系列可以在编译期提供额外信息的类，它们被封装在了头文件里面，在这个头文件里，有若干分类：用来创建编译期常量的`helper`类，用来编译期获取类型信息的类型萃取类，为了可以把现存类型转换为新类型的类型转换类
   > 9. decltype类型指示符
   > 10. 容器的cbegin()和cend(),

4. 拷贝构造函数的参数必须是引用的形式传递的，这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。

   1. 对象作为函数参数，以值传递的方式传给函数

   2. 对象作为函数返回值，以值的方式从函数返回

   3. 使用一个对象给另一个对象初始化

   4. >拷贝构造函数的规则
      >
      >对于值类型的成员进行值复制
      >
      >对于指针和动态分配的空间，在拷贝中应重新分配分配空间
      >
      >对于基类，要调用基类合适的拷贝方法，完成基类的拷贝

   5. 拷贝构造函数和赋值运算符的行为比较相似，却产生不同的结果；拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。

5. 智能指针的实现

   > 1. auto_ptr中禁止使用operator=，这样会失去所有权；
   >
   >    1. auto_ptr的release函数只是让出内存所有权。不会释放对象
   >    2. auto_ptr最好不要当成参数传递。
   >    3. 不能放入vector容器中。
   >
   > 2. shared_ptr属于boost中，定义在namespace boost中。共享所有权，其在内部使用了引用指针，用于管理单个堆内存对象的。
   >
   >    1. 没有release函数
   >    2. 可以支持复制、参数传递
   >
   > 3. weak_ptr是shared_ptr的观察者对象
   >
   > 4. ```c++
   >    //
   >    //  main.cpp
   >    //  0000
   >    //
   >    //  Created by NL on 2017/8/27.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include <memory.h>
   >    using namespace std
   >    ;
   >    class Point {
   >    private:
   >        int x, y;
   >    public:
   >        Point(int xv=0, int yv=0):x(xv),y(yv){}
   >        void SetX(int _x) {
   >            x = _x;
   >        }
   >        void SetY(int _y) {
   >            y = _y;
   >        }
   >        int GetX() const {
   >            return x;
   >        }
   >        int GetY() const {
   >            return y;
   >        }
   >    };
   >
   >    class RefPtr {
   >        friend class SmartPtr;
   >        RefPtr(Point *ptr):p(ptr),count(1){}
   >        ~RefPtr() { delete p; }
   >        int count;
   >        Point *p;
   >    };
   >
   >    class SmartPtr {
   >    public:
   >        SmartPtr(Point *ptr):rp(new RefPtr(ptr)) {}
   >        SmartPtr(const SmartPtr &sp):rp(sp.rp) { ++rp->count; }
   >        SmartPtr& operator = (const SmartPtr &rhs) {
   >            ++rhs.rp->count;
   >            if (--rp->count == 0)
   >                delete rp;
   >            rp = rhs.rp;
   >            return *this;
   >        }
   >        ~SmartPtr() {
   >            if (--rp->count == 0)
   >                delete rp;
   >        }
   >        int Use_count() const {
   >            return rp->count;
   >        }
   >    private:
   >        RefPtr *rp;
   >    };
   >
   >    int main() {
   >        Point *p1 = new Point(10, 8);
   >        SmartPtr sp1(p1);
   >        SmartPtr sp2(sp1);
   >        cout<<sp2.Use_count()<<endl;
   >        Point *p2 = new Point(5, 5);
   >        SmartPtr sp3(p2);
   >        sp3 = sp1;
   >        cout<<sp3.Use_count()<<endl;
   >    }
   >    ```

6. [面试1](http://blog.csdn.net/worldwindjp/article/details/18909079).

7. [面试2](http://blog.csdn.net/worldwindjp/article/details/12967443).

8. [面试3](http://blog.csdn.net/worldwindjp/article/details/18909631)

9. [面试4](http://blog.csdn.net/worldwindjp/article/details/18843087)

10. inline关键字要放在函数定义时，这样才能把函数内联。

11. String类的实现

    ```c++
    //
    //  String.hpp
    //  String
    //
    //  Created by NL on 2017/8/27.
    //  Copyright © 2017年 NL. All rights reserved.
    //

    #ifndef String_hpp
    #define String_hpp
    #include <cstdio>
    #include <iostream>
    using namespace std;
    class String {
    private:
        char *_data;
        size_t size;
    public:
        ~String();
        String(const char *str=nullptr);
        String(const String &str);
        
        String& operator = (const String &str);
        String operator+(const String &str) const;
        String& operator+=(const String &str);
        bool operator == (const String &str) const;
        
        size_t Getsize() const;
        const char *c_str() const;
        char& operator[](int n) const;
        friend istream& operator >> (istream &is, String &str);
        friend ostream& operator << (ostream &os, String &str);
    };
    #endif /* String_hpp */
    //
    //  String.cpp
    //  String
    //
    //  Created by NL on 2017/8/27.
    //  Copyright © 2017年 NL. All rights reserved.
    //
    #include "String.hpp"
    #include <cstdio>
    #include <cstring>
    using namespace std;
    String::String(const char *str) {  //通用构造函数
        if (str == nullptr) {
            size = 0;
            _data = new char[1];
            *_data = '\0';
        }
        else {
            size = strlen(str);
            _data = new char[size+1];
            strcpy(_data, str);
        }
    }
    String::String(const String &str) {  //拷贝构造函数
        size = str.Getsize();
        _data = new char[size+1];
        strcpy(_data, str.c_str());
    }
    String::~String() {  // 析构函数
        size = 0;
        delete []_data;
    }
    String& String::operator+=(const String &str) {
        strcat(this->_data, str._data);
        return *this;
    }

    String& String::operator = (const String &str) {  //拷贝赋值操作符
        if (this == &str)
            return *this;
        delete []_data;
        size = str.Getsize();
        _data = new char[size+1];
        strcpy(_data, str.c_str());
        return *this;
    }
    String String::operator+(const String &str) const {  //返回另一个String
        String Newstr;
        Newstr.size = size+str.Getsize();
        Newstr._data = new char[Newstr.Getsize()+1];
        strcpy(Newstr._data, _data);
        strcat(Newstr._data, str.c_str());
        return Newstr;
    }
    // 比较函数
    bool String::operator == (const String &str) const {
        if (str.Getsize() != size)
            return false;
        return strcmp(_data, str.c_str())?false:true;
    }
    //重载[]
    inline char& String::operator[](int n) const{
        if (n<size)
            return _data[n];
        else
            return _data[size-1];
    }
    inline size_t String::Getsize() const {
        return size;
    }
    inline const char* String::c_str() const {
        return _data;
    }
    istream& operator >> (istream &is, String &str) {
        char tem[1000];
        is>>tem;
        str.size = strlen(tem);
        str._data = new char[str.size+1];
        strcpy(str._data, tem);
        return is;
    }
    ostream& operator << (ostream &os, String &str) {
        os<<str._data;
        return os;
    }
    //
    //  main.cpp
    //  String
    //
    //  Created by NL on 2017/8/27.
    //  Copyright © 2017年 NL. All rights reserved.
    //

    #include <iostream>
    #include "String.hpp"
    using namespace std;
    int main(int argc, const char * argv[]) {
        String s1;
        cin>>s1;
        String s2("Love");
        cout<<s2<<endl;
        String s3 = s1+s2;
        String s4(s3);
        s4 += s3;
        cout<<s4<<endl;
        s3 = s4;
        if (s4 == s3)
            cout<<"S4 == s3"<<endl;
        return 0;
    }
    ```

12. vector是一块连续内存，当空间不足了会在分配内存；list是双向链表；deque是是双端队列，可在头和尾部插入、删除元素。

13. 红黑树的特性：1. 根结点是黑色的，2、若节点为红色、其孩子节点必是黑色；3、根结点到每个叶子结点，黑色节点的树木相同。4、外部节点一定是黑色。

14. 模板特例化：特殊情况的实现。

15. 内存泄露和内存溢出

16. 配接器

17. STL仿函数和指针的差别。

18. 一元、二元仿函数

19. 类模版与函数模版的不同：

    1. 类模版的类型需要显示设定，函数模版的类型编译器会推断。
    2. 类模版的成员函数实例化：只有在程序使用它时才会被实例化，即使其类模版已经被实例化

20. [New、delete与malloc、free的区别](http://blog.csdn.net/hackbuteer1/article/details/6789164).

### 操作系统

1. 线程与进程长的区别
2. 产生死锁的四个必要条件

### 算法

1. 数组中出现次数超过一半的数


### SQL

1. ​