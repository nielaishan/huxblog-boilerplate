---
layout:   post
title:    "C++设计模式 二"
subtitle: "在路上，，，"
date:     2017-08-26
author:   "NL"
header-img: "img/post-bg-2015.jpg"
tags:
    - C++
---

### 行为模式

1. Template模式-模板方法模式

   > 1. 作用：定义一个操作中的算法的骨架。而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
   >
   > 2. AbstractClass是抽象类，其实也就是一个抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶层逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到之类实现。顶层逻辑也有可能调用一些具体方法。
   >
   >    ConcreteClass，实现父类所定义的一个或多个抽象方法。每一个AbstractClass都可以有任意多个ConcreteClass与之对应，而每一ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。
   >
   > 3. 模板方法模式是通过把不变行为搬移到基类，去除之类中的重复代码来体现它的优势。
   >
   >    当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。
   >
   >    ```c++
   >    //
   >    //  Template.hpp
   >    //  Template
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Template_hpp
   >    #define Template_hpp
   >
   >    #include <stdio.h>
   >    class AbstractClass{
   >    public:
   >        ~AbstractClass();
   >        //具体的模板方法，给出了逻辑的骨架，而逻辑的组成的一些相应的抽象操作，它们都推迟到子类中实现
   >        void TemplateMedthod();
   >        //一些抽象行为，放到子类中去实现
   >        virtual void PrimitiveOperation1()=0;
   >        virtual void PrimitiveOperation2()=0;
   >    protected:
   >        AbstractClass();
   >    };
   >    //实现基类所定义的抽象方法
   >    class ConcreteClassA: public AbstractClass {
   >    public:
   >        ConcreteClassA();
   >        ~ConcreteClassA();
   >        virtual void PrimitiveOperation1();
   >        virtual void PrimitiveOperation2();
   >    };
   >    class ConcreteClassB: public AbstractClass{
   >    public:
   >        ConcreteClassB();
   >        ~ConcreteClassB();
   >        virtual void PrimitiveOperation1();
   >        virtual void PrimitiveOperation2();
   >    };
   >    #endif /* Template_hpp */
   >    //
   >    //  Template.cpp
   >    //  Template
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Template.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    AbstractClass::AbstractClass(){}
   >    AbstractClass::~AbstractClass(){}
   >
   >    void AbstractClass::TemplateMedthod() {
   >        this->PrimitiveOperation1();
   >        this->PrimitiveOperation2();
   >    }
   >
   >    ConcreteClassA::ConcreteClassA(){}
   >    ConcreteClassA::~ConcreteClassA(){}
   >    void ConcreteClassA::PrimitiveOperation1(){
   >        cout<<"ConcreteClassA::PrimitiveOperation1"<<endl;
   >    }
   >
   >    void ConcreteClassA::PrimitiveOperation2(){
   >        cout<<"ConcreteClassA::PrimitiveOperation2"<<endl;
   >    }
   >
   >    ConcreteClassB::ConcreteClassB(){}
   >    ConcreteClassB::~ConcreteClassB(){}
   >    void ConcreteClassB::PrimitiveOperation1(){
   >        cout<<"ConcreteClassB::PrimitiveOperation1"<<endl;
   >    }
   >
   >    void ConcreteClassB::PrimitiveOperation2(){
   >        cout<<"ConcreteClassB::PrimitiveOperation2"<<endl;
   >    }
   >    //
   >    //  main.cpp
   >    //  Template
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Template.hpp"
   >    int main(int argc, const char * argv[]) {
   >        AbstractClass *pAbstract = new ConcreteClassA();
   >        pAbstract->TemplateMedthod();
   >        pAbstract = new ConcreteClassB();
   >        pAbstract->TemplateMedthod();
   >        return 0;
   >    }
   >    /*
   >    ConcreteClassA::PrimitiveOperation1
   >    ConcreteClassA::PrimitiveOperation2
   >    ConcreteClassB::PrimitiveOperation1
   >    ConcreteClassB::PrimitiveOperation2
   >    */
   >    ```
   >
   > 4. 代码说明：其关键是将通用算法封装起来，而将算法细节让子类实现
   >
   > 5. 讨论：Template是采用继承的方式实现算法的异构，其关键点就是将通用算法封装在抽象基类中，将不同的算法细节放到子类中实现。

2. Strategy模式-策略模式

   > 1. 作用：定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
   >
   > 2. Strategy模式将逻辑（算法）封装到一个类（Context）里面，通过组合的方式将具体算法的实现在组合对象中实现，再通过委托的方式将抽象接口的实现委托给组合对象实现
   >
   >    将算法的逻辑抽象接口（DoAction）封装到一个类中（Context），再通过委托的方式将具体的算法实现委托给具体的Strategy类来实现（ConcreteStrategeA类）
   >
   >    Stragegy类，定义所有支持的算法的公共接口
   >    ConcreteStrategy，封装了具体的算法或行为，继承于Strategy
   >    Context，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。
   >
   > 3. ```c++
   >    //
   >    //  Strategy.hpp
   >    //  Strategy
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Strategy_hpp
   >    #define Strategy_hpp
   >
   >    #include <stdio.h>
   >    class Strategy {
   >    public:
   >        ~Strategy();
   >        virtual void AlgrithmInterface() = 0;
   >    protected:
   >        Strategy();
   >    };
   >
   >    class ConcreteStrategyA: public Strategy{
   >    public:
   >        ConcreteStrategyA();
   >        ~ConcreteStrategyA();
   >        virtual void AlgrithmInterface();
   >    };
   >
   >    class ConcreteStrategyB:public Strategy {
   >    public:
   >        ConcreteStrategyB();
   >        ~ConcreteStrategyB();
   >        virtual void AlgrithmInterface();
   >    };
   >
   >    /*
   >     这个类是strategy模式的关键
   >     也是Strategy模式和Template模式的根本区别所在
   >     *Strategy通过组合方式实现算法的异构
   >     而Template模式则采用继承方式
   >     这两个模式的区别也是继承和组合两种实现接口重用的方式的区别
   >     */
   >
   >    class Context {
   >    public:
   >        Context(Strategy *);
   >        ~Context();
   >        void DoAction();
   >    private:
   >        Strategy *_strategy;
   >    };
   >    #endif /* Strategy_hpp */
   >    //
   >    //  Strategy.cpp
   >    //  Strategy
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Strategy.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    Strategy::Strategy() {}
   >    Strategy::~Strategy(){}
   >    ConcreteStrategyA::ConcreteStrategyA(){}
   >    ConcreteStrategyA::~ConcreteStrategyA(){}
   >    void ConcreteStrategyA::AlgrithmInterface() {
   >        cout<<"ConcreteStrategyA::AlgrithmInterface"<<endl;
   >    }
   >
   >    ConcreteStrategyB::ConcreteStrategyB(){}
   >    ConcreteStrategyB::~ConcreteStrategyB(){}
   >    void ConcreteStrategyB::AlgrithmInterface(){
   >        cout<<"ConcreteStrategyB::AlgrithmInterface"<<endl;
   >    }
   >
   >    Context::Context(Strategy *st):_strategy(st) {
   >    }
   >    Context::~Context() {
   >        delete _strategy;
   >    }
   >
   >    void Context::DoAction() {
   >        this->_strategy->AlgrithmInterface();
   >    }
   >    //
   >    //  main.cpp
   >    //  Strategy
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Strategy.hpp"
   >    int main(int argc, const char * argv[]) {
   >        Strategy *pStr = new ConcreteStrategyA();
   >        Context *pcon = new Context(pStr);
   >        pcon->DoAction();
   >        pStr = new ConcreteStrategyB();
   >        pcon = new Context(pStr);
   >        pcon->DoAction();
   >        return 0;
   >    }
   >    /*
   >    ConcreteStrategyA::AlgrithmInterface
   >    ConcreteStrategyB::AlgrithmInterface
   >    Strategy模式和Template模式实际是实现一个抽象接口的两种方式：继承和组合之间的区别。
   >    要实现一个抽象接口，继承是一种方式：我们将抽象接口声明在基类中，将具体的实现放在具体子类中。
   >    组合（委托）是另外一种方式：我们将接口的实现放在被组合对象中，将抽象接口放在组合类中。
   >    这两种方式各有优缺点
   >    */
   >    ```
   >
   > 4. 代码说明：关键是将算法的逻辑封装到一个类中
   >
   > 5. 讨论：Strategy模式和Template模式实际上是实现一个抽象接口的两种方式：继承和组合之间的区别。要实现一个抽象接口，继承是一种方式：我们将抽象接口声明在基类中，将具体的实现在具体子类中；组合是另外一种方式，我们将接口的实现放在被组合对象中，将抽象接口放在组合类中。
   >
   > 6. 两种方式的优缺点：
   >
   >    - 继承
   >      1. 优点：易于修改和扩展那些被复用的实现
   >      2. 缺点：
   >         1. 破坏了封装性，继承中父类的实现细节暴露给子类了
   >         2. “白盒”复用
   >         3. 当父类的实现更改时，其所有子类将不得不随之改变
   >         4. 从父类继承而来的实现在运行期间不能改变
   >    - 组合
   >      1. 优点：
   >         1. 黑盒复用，因为被包含对象的内部细节对外不可见
   >         2. 封装性好
   >         3. 实现和抽象的依赖性小
   >         4. 可以在运行期间动态定义实现
   >      2. 缺点：系统中对象过多

3. State模式-状态模式

   > 1. 概述：对象如何在每一种状态下表现出不同的行为？
   >
   > 2. 作用：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
   >
   > 3. State类，抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为。
   >    ConcreteState类，具体状态，每一个子类实现一个与Context的一个状态相关的行为。
   >    Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态。
   >
   > 4. ```c++
   >    //
   >    //  State.hpp
   >    //  State
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef State_hpp
   >    #define State_hpp
   >
   >    #include <stdio.h>
   >    class Context;
   >    class State {
   >    public:
   >        virtual ~State();
   >        virtual void Handle(Context *) = 0;
   >    protected:
   >        State();
   >    };
   >
   >    class ConcreteStateA:public State {
   >    public:
   >        ConcreteStateA();
   >        ~ConcreteStateA();
   >        virtual void Handle(Context *);
   >    };
   >
   >    class ConcreteStateB:public State {
   >    public:
   >        ConcreteStateB();
   >        ~ConcreteStateB();
   >        virtual void Handle(Context *);
   >    };
   >
   >    class ConcreteStateC:public State {
   >    public:
   >        ConcreteStateC();
   >        ~ConcreteStateC();
   >        virtual void Handle(Context *);
   >    };
   >
   >    class Context{
   >    public:
   >        Context(State* pState);
   >        ~Context();
   >        void Request();
   >        void ChangeState(State *pState);
   >    private:
   >        State *_state;
   >    };
   >
   >    #endif /* State_hpp */
   >    //
   >    //  State.cpp
   >    //  State
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "State.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    State::State(){}
   >    State::~State(){}
   >    ```
   >
   >
   >    ConcreteStateA::ConcreteStateA() {}
   >    ConcreteStateA::~ConcreteStateA(){}
   >    void ConcreteStateA::Handle(Context *con) {
   >        cout<<"ConcreteStateA"<<endl;
   >        con->ChangeState(new ConcreteStateB());
   >    }
   >
   >    ConcreteStateB::ConcreteStateB() {}
   >    ConcreteStateB::~ConcreteStateB(){}
   >    void ConcreteStateB::Handle(Context *con) {
   >        cout<<"ConcreteStateB"<<endl;
   >        con->ChangeState(new ConcreteStateC());
   >    }
   >
   >    ConcreteStateC::ConcreteStateC() {}
   >    ConcreteStateC::~ConcreteStateC(){}
   >    void ConcreteStateC::Handle(Context *con) {
   >        cout<<"ConcreteStateC"<<endl;
   >        con->ChangeState(new ConcreteStateA());
   >    }
   >
   >    Context::Context(State* pState):_state(pState) {
   >    }
   >
   >    Context::~Context(){
   >        delete _state;
   >    }
   >    void Context::Request(){
   >        if (nullptr != this->_state)
   >            this->_state->Handle(this);
   >    }
   >
   >    void Context::ChangeState(State *pState) {
   >        this->_state = pState;
   >    }
   >    //
   >    //  main.cpp
   >    //  State
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "State.hpp"
   >    int main(int argc, const char * argv[]) {
   >        State *pState = new ConcreteStateA();
   >        Context *pcon = new Context(pState);
   >        pcon->Request();
   >        pcon->Request();
   >        pcon->Request();
   >        pcon->Request();
   >        pcon->Request();
   >        pcon->Request();
   >        return 0;
   >    }
   >    /*
   >    ConcreteStateA
   >    ConcreteStateB
   >    ConcreteStateC
   >    ConcreteStateA
   >    ConcreteStateB
   >    ConcreteStateC
   >    */
   >    ```
   >
   > 5. 讨论：State模式主要是要适应对象对于状态改变时的不同处理策略的实现，而Strategy模式则主要是具体算法和实现接口的解耦。
   >    ```

4. Observer模式-观察者模式

   > 1. **作用**：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己
   >
   > 2. Subject类，可翻译为主题或抽象通知者，一般用一个抽象类或者一个借口实现。它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个借口，可以增加和删除观察者对象。
   >
   >    Observer类，抽象观察者，为所有的具体观察者定义一个借口，在得到主题的通知时更新自己。这个借口叫做更新接口。抽象观察者一般用一个抽象类或者一个接口实现。更新接口通常包含一个Update()方法。
   >    ConcreteSubject类，叫做具体主题或具体通知者，将有关状态存入具体通知者对象；在具体主题的内部状态改变时，给所有等级过的观察者发出通知。通常用一个具体子类实现。
   >
   >    ConcreteObserver类，具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个指向一个具体主题对象的引用。
   >    特点：将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。
   >
   > 3. 何时使用：
   >    当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。
   >    观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。
   >
   > 4. ```c++
   >    //
   >    //  Observer.hpp
   >    //  Observer
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Observer_hpp
   >    #define Observer_hpp
   >
   >    #include <stdio.h>
   >    #include <string>
   >    #include <list>
   >    using namespace std;
   >    class Subject;
   >    class Observer{
   >    public:
   >        virtual ~Observer();
   >        virtual void Update(Subject *)=0;
   >    protected:
   >        Observer();
   >    };
   >
   >    class ConcreteObserverA:public Observer{
   >    public:
   >        ConcreteObserverA();
   >        ~ConcreteObserverA();
   >        virtual void Update(Subject *);
   >    private:
   >        string m_state;
   >    };
   >
   >    class ConcreteObserverB:public Observer{
   >    public:
   >        ConcreteObserverB();
   >        ~ConcreteObserverB();
   >        virtual void Update(Subject *);
   >    private:
   >        string m_state;
   >    };
   >    class Subject{
   >    public:
   >        ~Subject();
   >        virtual void Notify();
   >        virtual void Attach(Observer *);
   >        virtual void Detach(Observer *);
   >        virtual string GetState();
   >        virtual void SetState(string state);
   >    protected:
   >        Subject();
   >    private:
   >        string m_state;
   >        list<Observer*>m_lst;
   >    };
   >    class ConcreteSubjectA : public Subject{
   >    public:
   >        ConcreteSubjectA();
   >        ~ConcreteSubjectA();
   >        
   >    };
   >    class ConcreteSubjectB : public Subject{
   >    public:
   >        ConcreteSubjectB();
   >        ~ConcreteSubjectB();
   >        
   >    };
   >    #endif /* Observer_hpp */
   >    //
   >    //  Observer.cpp
   >    //  Observer
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Observer.hpp"
   >    #include <string>
   >    #include <iostream>
   >    using namespace std;
   >    Observer::Observer(){}
   >    Observer::~Observer(){}
   >    ConcreteObserverA::ConcreteObserverA(){}
   >    ConcreteObserverA::~ConcreteObserverA(){}
   >    void ConcreteObserverA::Update(Subject *sub) {
   >        this->m_state = sub->GetState();
   >        cout<<"the ConcreteObserverA is "<<m_state<<endl;
   >    }
   >
   >    ConcreteObserverB::ConcreteObserverB(){}
   >    ConcreteObserverB::~ConcreteObserverB(){}
   >    void ConcreteObserverB::Update(Subject *sub) {
   >        this->m_state = sub->GetState();
   >        cout<<"the ConcreteObserverB is "<<m_state<<endl;
   >    }
   >
   >    Subject::Subject() {}
   >    Subject::~Subject(){}
   >    void Subject::Attach(Observer *pObserver) {
   >        this->m_lst.push_back(pObserver);
   >        cout<<"Attach an Observer"<<endl;
   >    }
   >
   >    void Subject::Detach(Observer *pObserver) {
   >        list<Observer*>::iterator iter;
   >        iter = find(m_lst.begin(), m_lst.end(), pObserver);
   >        if (iter != m_lst.end())
   >            m_lst.erase(iter);
   >        cout<<"Detach an Observer"<<endl;
   >    }
   >
   >    void Subject::Notify() {
   >        list<Observer*>::iterator iter = this->m_lst.begin();
   >        for (;iter!=m_lst.end(); iter++)
   >            (*iter)->Update(this);
   >    }
   >
   >    void Subject::SetState(string state) {
   >        this->m_state = state;
   >    }
   >
   >    string Subject::GetState(){
   >        return m_state;
   >    }
   >
   >    ConcreteSubjectA::ConcreteSubjectA(){}
   >    ConcreteSubjectA::~ConcreteSubjectA(){}
   >    ConcreteSubjectB::ConcreteSubjectB(){}
   >    ConcreteSubjectB::~ConcreteSubjectB(){}
   >    //
   >    //  main.cpp
   >    //  Observer
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Observer.hpp"
   >    int main(int argc, const char * argv[]) {
   >        Observer *p1 = new ConcreteObserverA();
   >        Observer *p2 = new ConcreteObserverB();
   >        Observer *p3 = new ConcreteObserverA();
   >        Subject *pSubject = new ConcreteSubjectA();
   >        pSubject->Attach(p1);
   >        pSubject->Attach(p2);
   >        pSubject->Attach(p3);
   >        pSubject->SetState("old");
   >        pSubject->Notify();
   >        cout<<endl;
   >        pSubject->SetState("new");
   >        pSubject->Detach(p3);
   >        pSubject->Notify();
   >        return 0;
   >    }
   >
   >    /*
   >    Attach an Observer
   >    Attach an Observer
   >    Attach an Observer
   >    the ConcreteObserverA is old
   >    the ConcreteObserverB is old
   >    the ConcreteObserverA is old
   >
   >    Detach an Observer
   >    the ConcreteObserverA is new
   >    the ConcreteObserverB is new
   >    */
   >    ```
   >
   > 5. 代码说明：在Observer模式的实现中，Subject维护一个list作为存储其所有观察者的容器。每当调用Notifi操作操作就是遍历list中的Observer对象，并广播通知改变状态（调用Observer的Update操作）。目标状态state可以由Subject自己改变（示列），也可以由Observer的某个操作引起state的改变，可调用Subject的SetState。

5. Memento模式-备忘录模式

   > 1. 作用：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。
   >
   > 2. Originator：负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。
   >
   >    Memento:负责存储Originator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento。备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。Originator能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。
   >
   >    Caretaker：负责保存好备忘录Memento,不能对备忘录的内容进行操作或检查。
   >
   > 3. Memento模式中封装的是需要保存的状态,当需要恢复的时候才取出来进行恢复.原理很简单,实现的时候需要注意一个地方:窄接口和宽接口.所谓的宽接口就是一般意义上的接口,把对外的接口作为public成员;而窄接口反之,把接口作为private成员,而把需要访问这些接口函数的类作为这个类的友元类,也就是说接口只暴露给了对这些接口感兴趣的类,而不是暴露在外部.下面的实现就是窄实现的方法来实现的.
   >
   >    Memento模式比较适用于功能比较复杂的，但需要维护或记录历史属性的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。
   >
   >    如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。
   >
   > 4. ```c++
   >    //
   >    //  Memento.hpp
   >    //  Memento
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Memento_hpp
   >    #define Memento_hpp
   >
   >    #include <stdio.h>
   >    #include <string>
   >    using namespace std;
   >    //负责存储Originator对象的内部状态，并可防止Originator以外 的其他对象访问备忘录Memento
   >    //备忘录有两个接口，Caretaker只能看到备忘录的窄接口，他只能讲备忘录传递给其他对象，Originantor能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据
   >
   >    class Memento {
   >    private:
   >        friend class Originator;
   >        Memento(const string &state);
   >        ~Memento();
   >        void SetState(const string &state);
   >        string GetState();
   >        string _state;
   >    };
   >
   >    class Originator{
   >    public:
   >        Originator();
   >        Originator(const string &state);
   >        ~Originator();
   >        void RestoreToMemento(Memento *pMemento);
   >        Memento* CreateMemento();
   >        void SetState(const string &state);
   >        string GetState();
   >        void show();
   >    private:
   >        string _state;
   >    };
   >
   >    class Caretaker{
   >    public:
   >        Caretaker();
   >        ~Caretaker();
   >        void SetMemento(Memento *);
   >        Memento* GetMemento();
   >    private:
   >        Memento *_memento;
   >    };
   >
   >    #endif /* Memento_hpp */
   >    //
   >    //  Memento.cpp
   >    //  Memento
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Memento.hpp"
   >    #include <string>
   >    #include <iostream>
   >    using namespace std;
   >    Memento::Memento(const string &state){
   >        this->_state = state;
   >    }
   >    Memento::~Memento() {}
   >    string Memento::GetState(){
   >        return this->_state;
   >    }
   >    void Memento::SetState(const string &state) {
   >        this->_state = state;
   >    }
   >
   >    Originator::Originator(){
   >    }
   >    Originator::Originator(const string &state) {
   >        this->_state = state;
   >    }
   >    Originator::~Originator(){}
   >    string Originator::GetState(){
   >        return _state;
   >    }
   >    void Originator::show(){
   >        cout<<_state<<endl;
   >    }
   >    void Originator::SetState(const string &state) {
   >        this->_state = state;
   >    }
   >    Memento* Originator::CreateMemento(){
   >        return new Memento(this->_state);
   >    }
   >    void Originator::RestoreToMemento(Memento *pMemento) {
   >        this->_state = pMemento->GetState();
   >    }
   >    Caretaker::~Caretaker(){}
   >    Caretaker::Caretaker() {}
   >    Memento* Caretaker::GetMemento(){
   >        return this->_memento;
   >    }
   >    void Caretaker::SetMemento(Memento *pMemento) {
   >        this->_memento = pMemento;
   >    }
   >    //
   >    //  main.cpp
   >    //  Memento
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Memento.hpp"
   >    int main(int argc, const char * argv[]) {
   >        //初始化对象，状态为old
   >        Originator* o = new Originator("old");
   >        o->show();
   >        //建立并保存Memento对象
   >        Caretaker *pTaker = new Caretaker();
   >        pTaker->SetMemento(o->CreateMemento());
   >        o->SetState("new");//改变状态
   >        o->show();
   >        o->RestoreToMemento(pTaker->GetMemento());//恢复状态
   >        o->show();
   >        return 0;
   >    }
   >    /*
   >    old
   >    new
   >    old
   >    */
   >    ```
   >
   > 5. 代码说明：Memento模式的关键是friend class Originator；我们可以看到，Memento的接口都声明为private，而将Origiantor声明为Memento的友元类，我们将Originator的状态保存在Memento类中，而将Memento接口private，也就达到了封装的功效
   >
   > 6. 在Command模式中，Memento模式经常被用来维护可以撤销操作的状态。

6. Mediator模式 -中介者模式

   > 1. **作用**：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
   >
   > 2. Colleage抽象同事类，而ConcreteColleage是具体同时类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但它们却都认识中介者对象，Mediator是抽象中介者，定义了同事对象到中介者对象的接口，ConcreteMediator是具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接受消息，向具体同事对象发出命令。
   >
   >    Colleage类，抽象同事类
   >
   >    Mediator，抽象中介者类
   >
   > 3. 说明：
   >
   >    1. Mediator 模式中，每个Colleague 维护一个 Mediator，当要进行通信时，每个具体的 Colleague 直接向ConcreteMediator 发信息，至于信息发到哪里，则由 ConcreteMediator 来决定。
   >    2. ConcreteColleagueA 和 ConcreteColleagueB 不必维护对各自的引用，甚至它们也不知道各个的存在。
   >    3. 优点是，各个 Colleague 减少了耦合。
   >    4. 缺点是，由于 Mediator 控制了集中化，于是就把 Colleague 之间的交互复杂性变为了中介者的复杂性，也就是中介者会变的比任何一个 Colleague 都复杂。
   >
   >    中介者模式很容易在系统中应用，也很容易在系统中误用。当系统中出现了“多对多”交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。
   >
   >    Mediator的出现减少了各个Colleage的耦合，使得可以独立地改变和复用各个Colleage类和Mediator;
   >    由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。
   >    由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这使得中介者会变得比任何一个ConcreteColleage都复杂。
   >
   >    中介者模式的优点来自集中控制，其缺点也是它。
   >
   >    中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合。
   >
   > 4. ```c++
   >    //
   >    //  Mediator.hpp
   >    //  Mediator
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Mediator_hpp
   >    #define Mediator_hpp
   >
   >    #include <stdio.h>
   >    #include <iostream>
   >    #include <string>
   >    using namespace std;
   >    class Mediator;
   >    class Colleage{
   >    public:
   >        virtual ~Colleage();
   >        virtual void SetMediator(Mediator *);
   >        virtual void SendMsg(string)=0;
   >        virtual void GetMsg(string)=0;
   >    protected:
   >        Colleage(Mediator*);
   >        Mediator *_mediator;
   >    };
   >
   >    class ConcreteColleageA:public Colleage{
   >    public:
   >        ~ConcreteColleageA();
   >        ConcreteColleageA(Mediator *);
   >        virtual void SendMsg(string);
   >        virtual void GetMsg(string);
   >    };
   >
   >    class ConcreteColleageB:public Colleage{
   >    public:
   >        ~ConcreteColleageB();
   >        ConcreteColleageB(Mediator *);
   >        virtual void SendMsg(string);
   >        virtual void GetMsg(string);
   >    };
   >
   >    class Mediator{
   >    public:
   >        virtual ~Mediator();
   >        virtual void SendMsg(string, Colleage *) = 0;
   >    protected:
   >        Mediator();
   >    };
   >    class ConcreteMediator : public Mediator{
   >    public:
   >        ConcreteMediator();
   >        ~ConcreteMediator();
   >        void SetColleageA(Colleage *);
   >        void SetColleageB(Colleage *);
   >        virtual void SendMsg(string msg, Colleage *);
   >    private:
   >        Colleage* m_colleageA;
   >        Colleage* m_colleageB;
   >    };
   >    #endif /* Mediator_hpp */
   >    //
   >    //  Mediator.cpp
   >    //  Mediator
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Mediator.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    Colleage::Colleage(Mediator *pMediator):_mediator(pMediator){
   >    }
   >    Colleage::~Colleage(){}
   >    void Colleage::SetMediator(Mediator *pMediator) {
   >        this->_mediator = pMediator;
   >    }
   >    ConcreteColleageA::ConcreteColleageA(Mediator *pMediator):Colleage(pMediator){}
   >    ConcreteColleageA::~ConcreteColleageA(){}
   >    void ConcreteColleageA::SendMsg(string msg) {
   >        this->_mediator->SendMsg(msg, this);
   >    }
   >    void ConcreteColleageA::GetMsg(string msg) {
   >        cout<<"ConcreteColleageA Receive "<<msg<<endl;
   >    }
   >    ConcreteColleageB::ConcreteColleageB(Mediator *pMediator):Colleage(pMediator){}
   >    ConcreteColleageB::~ConcreteColleageB(){}
   >    void ConcreteColleageB::SendMsg(string msg) {
   >        this->_mediator->SendMsg(msg, this);
   >    }
   >    void ConcreteColleageB::GetMsg(string msg) {
   >        cout<<"ConcreteColleageB Receive "<<msg<<endl;
   >    }
   >    Mediator::Mediator(){}
   >    Mediator::~Mediator(){}
   >    ConcreteMediator::ConcreteMediator(){}
   >    ConcreteMediator::~ConcreteMediator(){}
   >    void ConcreteMediator::SetColleageA(Colleage *p) {
   >        this->m_colleageA = p;
   >    }
   >    void ConcreteMediator::SetColleageB(Colleage *p) {
   >        this->m_colleageB = p;
   >    }
   >    void ConcreteMediator::SendMsg(string msg, Colleage *p) {
   >        if (p == this->m_colleageA)
   >            this->m_colleageB->GetMsg(msg);
   >        else if(p == this->m_colleageB)
   >            this->m_colleageA->GetMsg(msg);
   >    }
   >    //
   >    //  main.cpp
   >    //  Mediator
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Mediator.hpp"
   >    int main(int argc, const char * argv[]) {
   >        ConcreteMediator *pMediator = new ConcreteMediator();
   >        Colleage *p1 = new ConcreteColleageA(pMediator);
   >        Colleage *p2 = new ConcreteColleageB(pMediator);
   >        pMediator->SetColleageB(p2);
   >        pMediator->SetColleageA(p1);
   >        p1->SendMsg("xxx");
   >        p2->SendMsg("ooo");
   >        return 0;
   >    }
   >    /*
   >    ConcreteColleageB Receive xxx
   >    ConcreteColleageA Receive ooo
   >    */
   >    ```
   >
   > 5. 代码说明：Mediator模式的实现关键就是的对象Colleage之间的通信封装到一个类种单独处理，为了模拟Mediator模式的功能，这里每个Colleage对象一个string型以记录其状态
   >
   > 6. 讨论：Mediator模式是一种很有用并且很常用的模式，他通过将对象间的通信封装到一个类中，将多对多的通信转化为一对多的通信，降低了系统的复杂性。Mediator还获得系统解耦的特性，通过Mediator，各个Colleage就不必维护各自通信的对象和通信协议，降低了系统的耦合性，Mediatro和Colleage就可以相互独立地修改了。

7. Command模式 -命令模式

   > 1. **作用**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。由于“行为请求者”与“行为实现者”的紧耦合，使用命令模式，可以对请求排队或记录请求日志，以及支持可撤销的操作。
   >
   > 2. Command类，用来声明执行操作的接口
   >
   >    ConcreteCommand,将一个接收者对象绑定于一个操作，调用接收者相应的操作，以实现Execute
   >
   >    Invoker类，要求该命令执行这个请求
   >
   >    Receiver类，知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。
   >    Command模式通过将请求封装到一个对象Command中，并将请求的接收者存放到具体的ConcreteCommand类中，从而实现调用操作的对象和操作的具体实现者之间的解耦。
   >    Command模式结构图中，将请求的接收者（处理者）放到Command的具体子类ConcreteCommand中，当请求到来时(Invoker发出Invoke消息激活Command对象)，ConcreteCommand将处理请求交给Receiver对象进行处理。
   >
   > 3. 优点
   >
   >    1. 它能较容易地设计一个命令队列。
   >    2. 在需要的情况下，可以较容易地将命令记入日志。
   >    3. 允许接受请求的一方决定是否要否决请求
   >    4. 可以容易地实现对请求的撤销和重做。
   >    5. 由于加进版的具体命令不影响其他的类，因此增加新的具体命令类很容易
   >
   > 4. ```c++
   >    //
   >    //  Command.hpp
   >    //  Command
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Command_hpp
   >    #define Command_hpp
   >
   >    #include <stdio.h>
   >    class Command{
   >    public:
   >        virtual ~Command();
   >        virtual void Execute() = 0;
   >    protected:
   >        Command();
   >    };
   >    class Receiver;
   >    class ConcreteCommand:public Command{
   >    public:
   >        ConcreteCommand(Receiver *pReceiver);
   >        ~ConcreteCommand();
   >        virtual void Execute();
   >    private:
   >        Receiver *_recv;
   >    };
   >    class Invoker{
   >    public:
   >        Invoker(Command *pCommand);
   >        ~Invoker();
   >        void Invoke();
   >    private:
   >        Command* _cmd;
   >    };
   >    class Receiver{
   >    public:
   >        Receiver();
   >        ~Receiver();
   >        void Action();
   >    };
   >    #endif /* Command_hpp */
   >    //
   >    //  Command.cpp
   >    //  Command
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Command.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    Command::Command(){}
   >    Command::~Command(){}
   >    ConcreteCommand::ConcreteCommand(Receiver *pReceiver):_recv(pReceiver){}
   >    ConcreteCommand::~ConcreteCommand(){}
   >    void ConcreteCommand::Execute(){
   >        this->_recv->Action();
   >    }
   >
   >    Receiver::Receiver(){}
   >    Receiver::~Receiver(){}
   >    void Receiver::Action(){
   >        cout<<"Receiver Action"<<endl;
   >    }
   >
   >    Invoker::Invoker(Command *pCommand):_cmd(pCommand) {}
   >    Invoker::~Invoker(){}
   >    void Invoker::Invoke() {
   >        this->_cmd->Execute();
   >    }
   >    //
   >    //  main.cpp
   >    //  Command
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Command.hpp"
   >    int main(int argc, const char * argv[]) {
   >        //创建具体命令对象pCmd并设定它的接受者pRev
   >        Receiver *pRev = new Receiver();
   >        Command *pCmd = new ConcreteCommand(pRev);
   >        //请求绑定命令
   >        Invoker *pInv = new Invoker(pCmd);
   >        pInv->Invoke();
   >        return 0;
   >    }
   >    ```
   >
   > 5. 代码说明：Command模式在实现的思想的都很简单，其关键就是将一个请求封装到一个类中（command），在提供处理对象（Receiver），最后Command命令由Invoker激活。另外我们可以将请求接受者的处理抽象出来作为参数传给Command对象，实际上就是回调的机制来实现这一点。
   >
   > 6. 讨论：
   >
   >    1. Command模式将调用操作的对象和知道如何实现该操作的对象解耦。
   >    2. 在Command要增加新的处理操作对象很容易，我们可以通过创建新的继承自Command的子类实现这一点

8. Visitor模式 -访问者模式

   > 1. 将更新封装到一个类中，并由代更改类提供一个接受接口，则可达到效果
   >
   > 2. Visitor模式在不破坏类的前提下，为类提供增加新的操作，Visitor模式的关键就是双分派（意味着执行的操作将取决于请求的种类和接受者的类型）的技术。C++语言支持是单分派
   >
   > 3. 在Visitor模式中Accept（）操作就是一个双分派的操作。具体调用哪一个具体的Accept（）操作，有两个决定因素：1、Element的类型。因为Accept（）是多态的操作，需要具体的Element类型的子类才可以决定调用那一个Accept（）实现；2、Visitor的类型。Accept（）有一个参数（Visitor *vis），要决定了实际传进来的Visitor的实际类别才可以具体是调用那个VisitConcrete（）实现
   >
   > 4. ```c++
   >    //
   >    //  Visitor.hpp
   >    //  Visitor
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Visitor_hpp
   >    #define Visitor_hpp
   >
   >    #include <stdio.h>
   >    class Element;
   >    class ConcreteElementA;
   >    class ConcreteElementB;
   >    class Visitor {
   >    public:
   >        virtual ~Visitor();
   >        virtual void VisitConcreteElementA(const Element &)=0;
   >        virtual void VisitConcreteElementB(const Element &)=0;
   >    protected:
   >        Visitor();
   >    };
   >
   >    class ConcreteVisitorA:public Visitor{
   >    public:
   >        ConcreteVisitorA();
   >        virtual ~ConcreteVisitorA();
   >        virtual void VisitConcreteElementA(const Element &);
   >        virtual void VisitConcreteElementB(const Element &);
   >    };
   >    class ConcreteVisitorB:public Visitor{
   >    public:
   >        ConcreteVisitorB();
   >        virtual ~ConcreteVisitorB();
   >        virtual void VisitConcreteElementA(const Element &);
   >        virtual void VisitConcreteElementB(const Element &);
   >    };
   >    #endif /* Visitor_hpp */
   >    //
   >    //  Element.hpp
   >    //  Visitor
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Element_hpp
   >    #define Element_hpp
   >
   >    #include <stdio.h>
   >    #include "Visitor.hpp"
   >
   >    class Element{
   >    public:
   >        virtual ~Element();
   >        virtual void Accept(Visitor *) = 0;
   >    protected:
   >        Element();
   >    };
   >
   >    class ConcreteElementA:public Element{
   >    public:
   >        ConcreteElementA();
   >        ~ConcreteElementA();
   >        virtual void Accept(Visitor *);
   >    };
   >
   >    class ConcreteElementB:public Element {
   >    public:
   >        ConcreteElementB();
   >        ~ConcreteElementB();
   >        virtual void Accept(Visitor *);
   >    };
   >    #endif /* Element_hpp */
   >    //
   >    //  Visitor.cpp
   >    //  Visitor
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Visitor.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    Visitor::Visitor(){}
   >    Visitor::~Visitor(){}
   >    ConcreteVisitorA::ConcreteVisitorA(){}
   >    ConcreteVisitorA::~ConcreteVisitorA(){}
   >    void ConcreteVisitorA::VisitConcreteElementA(const Element &elm) {
   >        cout<<"I will visit ConcreteElementA"<<endl;
   >    }
   >    void ConcreteVisitorA::VisitConcreteElementB(const Element &elm) {
   >        cout<<"I will visit ConcreteElementB"<<endl;
   >    }
   >
   >    ConcreteVisitorB::ConcreteVisitorB(){}
   >    ConcreteVisitorB::~ConcreteVisitorB(){}
   >    void ConcreteVisitorB::VisitConcreteElementA(const Element &elm) {
   >        cout<<"I will visit ConcreteElementA"<<endl;
   >    }
   >    void ConcreteVisitorB::VisitConcreteElementB(const Element &elm) {
   >        cout<<"I will visit ConcreteElementB"<<endl;
   >    }
   >    //
   >    //  Element.cpp
   >    //  Visitor
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Element.hpp"
   >    #include <iostream>
   >    #include "Visitor.hpp"
   >    using namespace std;
   >    Element::Element(){}
   >    Element::~Element(){}
   >    ConcreteElementA::ConcreteElementA(){}
   >    ConcreteElementA::~ConcreteElementA(){}
   >    void ConcreteElementA::Accept(Visitor *vis) {
   >        vis->VisitConcreteElementA(*this);
   >        cout<<"Visiting ConcreteElementA"<<endl;
   >    }
   >
   >    ConcreteElementB::ConcreteElementB(){}
   >    ConcreteElementB::~ConcreteElementB(){}
   >    void ConcreteElementB::Accept(Visitor *vis) {
   >        vis->VisitConcreteElementB(*this);
   >        cout<<"Visiting ConcreteElementB"<<endl;
   >    }
   >    //
   >    //  main.cpp
   >    //  Visitor
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Element.hpp"
   >    #include "Visitor.hpp"
   >    int main(int argc, const char * argv[]) {
   >        Visitor *vis = new ConcreteVisitorA();
   >        Element* elm = new ConcreteElementA();
   >        elm->Accept(vis);
   >        return 0;
   >    }
   >    /*
   >    I will visit ConcreteElementA
   >    Visiting ConcreteElementA
   >    */
   >    ```
   >
   > 5. 代码说明：Visitor类中的Visit()操作的实现
   >
   >    1. 这里我们可以向Element类仅仅提供一个接口Visit，而在Accept实现中具有调用那一个Visit操作则通过函数重载的方式实现：我们提供Visit的两个重载版本1. Visit(ConcreteElementA *elmA)， 2.Visit(ConcreteElementB *elmB)。
   >    2. 在C++中我们还可以通过RTTI（运行时类型识别）来实现，即我们只提供一个Visit函数体，传入的参数为Element*型别参数，然后用RTTI决定具体是哪一类的ConcreteElement参数，再决定具体要对哪个具体类施加什么样的具体操作。RTTI给接口带来了简单一致性，但是付出的代价是时间和代码的Hard编码。
   >
   > 6. 讨论：Visitor模式可以使得Element在不修改自己的同时增加新的操作，但这也带来了两个显著的问题
   >
   >    1. 破坏了封装性：Visitor模式要求Visitor可以在外部修改Element对象状态。1、Element提供足够的public接口，使得Visitor可以通过接口达到修改状态的目的。2、Element暴露更多的细节给Visitor。
   >    2. ConcreteElement的扩展很困难：每增加一个ELement的子类，就要修改Visitor的接口。

9. Chain of Responsibility模式 -职责链模式

   > 1. 作用：这样一类问题将可能处理一个请求的对象链接成一个链，并将请求在这个链上传递，直到有对象处理该请求。
   >
   > 2. 概述：Chain of Responsibiity模式中ConcreteHandler将自己的后继对象记录在自己的后继表中，当一个请求到来时，ConcreteHandler会先检查自己有没有匹配的处理程序，如果有自己处理，否则传递给他的后继。
   >
   > 3. ```c++
   >    //
   >    //  Handle.hpp
   >    //  Chain_of_Responsibility
   >    //
   >    //  Created by NL on 2017/8/27.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Handle_hpp
   >    #define Handle_hpp
   >
   >    #include <stdio.h>
   >    class Handle {
   >    public:
   >        virtual ~Handle();
   >        virtual void HandleRequest() = 0;
   >        virtual void SetSuccessor(Handle *succ);
   >        Handle *GetSuccessor();
   >    protected:
   >        Handle();
   >        Handle(Handle *succ);
   >    private:
   >        Handle *_succ;
   >    };
   >
   >    class ConcreteHandleA:public Handle {
   >    public:
   >        ConcreteHandleA();
   >        ~ConcreteHandleA();
   >        ConcreteHandleA(Handle *succ);
   >        void HandleRequest();
   >    };
   >
   >    class ConcreteHandleB:public Handle {
   >    public:
   >        ConcreteHandleB();
   >        ~ConcreteHandleB();
   >        ConcreteHandleB(Handle *succ);
   >        void HandleRequest();
   >    };
   >    #endif /* Handle_hpp */
   >    //
   >    //  Handle.cpp
   >    //  Chain_of_Responsibility
   >    //
   >    //  Created by NL on 2017/8/27.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Handle.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    Handle::Handle(){}
   >    Handle::Handle(Handle *succ) {
   >        this->_succ = succ;
   >    }
   >    Handle::~Handle(){
   >        delete _succ;
   >    }
   >    void Handle::SetSuccessor(Handle *succ) {
   >        _succ = succ;
   >    }
   >    Handle* Handle::GetSuccessor() {
   >        return _succ;
   >    }
   >    ConcreteHandleA::ConcreteHandleA(){}
   >    ConcreteHandleA::ConcreteHandleA(Handle *succ):Handle(succ){}
   >    ConcreteHandleA::~ConcreteHandleA(){}
   >    void ConcreteHandleA::HandleRequest() {
   >        if (this->GetSuccessor() != 0) {
   >            cout<<"ConcreteHandleA 交给后继节点"<<endl;
   >            this->GetSuccessor()->HandleRequest();
   >        }
   >        else
   >            cout<<"ConcreteHandleA 没有后继，自己处理"<<endl;
   >    }
   >
   >    ConcreteHandleB::ConcreteHandleB(){}
   >    ConcreteHandleB::ConcreteHandleB(Handle *succ):Handle(succ){}
   >    ConcreteHandleB::~ConcreteHandleB(){}
   >    void ConcreteHandleB::HandleRequest() {
   >        if (this->GetSuccessor() != 0) {
   >            cout<<"ConcreteHandleB 交给后继节点"<<endl;
   >            this->GetSuccessor()->HandleRequest();
   >        }
   >        else
   >            cout<<"ConcreteHandleB 没有后继，自己处理"<<endl;
   >    }
   >    //
   >    //  main.cpp
   >    //  Chain_of_Responsibility
   >    //
   >    //  Created by NL on 2017/8/27.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Handle.hpp"
   >    int main(int argc, const char * argv[]) {
   >        Handle *h1 = new ConcreteHandleA();
   >        Handle *h2 = new ConcreteHandleB();
   >        h1->SetSuccessor(h2);
   >        h1->HandleRequest();
   >        return 0;
   >    }
   >    /*
   >    ConcreteHandleA 交给后继节点
   >    ConcreteHandleB 没有后继，自己处理
   >    */
   >    ```
   >
   > 4. 代码说明：ConcreteHandleA的对象和h1拥有一个后继节点ConcreteHandleB的对象h2，当一个请求到来时，h1检查看自己有后继，于是h1直接将请求传递给其后继节点h2处理，h2没有后继，只能自己处理。
   >
   > 5. 讨论：给系统降低了耦合性，请求的发送者完全不知道请求会被那个应答对象处理，极大了降低了耦合性

10. Iterator模式 -迭代器模式

   > 1. 解决问题：对一个聚合对象的遍历问题，将对聚合的遍历封装到一个类中进行，这样就避免了暴露这个聚合对象的内部表示的可能
   >
   > 2. ```c++
   >    //
   >    //  Aggregate.hpp
   >    //  Iterator
   >    //
   >    //  Created by NL on 2017/8/27.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Aggregate_hpp
   >    #define Aggregate_hpp
   >
   >    #include <stdio.h>
   >    class Iterator;
   >    typedef int Object;
   >    class Aggregate {
   >    public:
   >        virtual ~Aggregate();
   >        virtual Iterator* CreateIterator() = 0;
   >        virtual Object GetItem(int idx) = 0;
   >        virtual int GetSize() = 0;
   >    protected:
   >        Aggregate();
   >    };
   >
   >    class ConcreteAggregate: public Aggregate {
   >    public:
   >        enum {SIZE = 3};  //静态数据
   >        ConcreteAggregate();
   >        ~ConcreteAggregate();
   >        Iterator* CreateIterator();
   >        Object GetItem(int idx);
   >        int GetSize();
   >    private:
   >        Object _objs[SIZE];
   >    };
   >    #endif /* Aggregate_hpp */
   >    //
   >    //  Iterator.hpp
   >    //  Iterator
   >    //
   >    //  Created by NL on 2017/8/27.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Iterator_hpp
   >    #define Iterator_hpp
   >
   >    #include <stdio.h>
   >    class Aggregate;
   >    typedef int Object;
   >    class Iterator {
   >    public:
   >        virtual ~Iterator();
   >        virtual void First() = 0;
   >        virtual void Next() = 0;
   >        virtual bool IsDone() = 0;
   >        virtual Object CurrentItem() = 0;
   >    protected:
   >        Iterator();
   >    };
   >
   >    class ConcreteIterator:public Iterator {
   >    public:
   >        ConcreteIterator(Aggregate*, int idx = 0);
   >        ~ConcreteIterator();
   >        void First();
   >        void Next();
   >        bool IsDone();
   >        Object CurrentItem();
   >    private:
   >        Aggregate *_ag;
   >        int _idx;
   >    };
   >    #endif /* Iterator_hpp */
   >    //
   >    //  Aggregate.cpp
   >    //  Iterator
   >    //
   >    //  Created by NL on 2017/8/27.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Aggregate.hpp"
   >    #include "Iterator.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    Aggregate::Aggregate(){}
   >    Aggregate::~Aggregate(){}
   >    ConcreteAggregate::ConcreteAggregate() {
   >        for (int i=0; i<SIZE; i++)
   >            _objs[i] = i;
   >    }
   >    ConcreteAggregate::~ConcreteAggregate(){}
   >    Iterator* ConcreteAggregate::CreateIterator() {
   >        return new ConcreteIterator(this);
   >    }
   >
   >    Object ConcreteAggregate::GetItem(int idx) {
   >        if (idx < this->GetSize())
   >            return _objs[idx];
   >        else
   >            return -1;
   >    }
   >    int ConcreteAggregate::GetSize(){
   >        return SIZE;
   >    }
   >    //
   >    //  Iterator.cpp
   >    //  Iterator
   >    //
   >    //  Created by NL on 2017/8/27.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Iterator.hpp"
   >    #include "Aggregate.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    Iterator::Iterator(){}
   >    Iterator::~Iterator(){}
   >    ConcreteIterator::ConcreteIterator(Aggregate *ag, int idx):_ag(ag), _idx(idx){
   >    }
   >    ConcreteIterator::~ConcreteIterator(){}
   >    Object ConcreteIterator::CurrentItem() {
   >        return _ag->GetItem(_idx);
   >    }
   >    void ConcreteIterator::First() {
   >        _idx = 0;
   >    }
   >    void ConcreteIterator::Next(){
   >        if (_idx < _ag->GetSize())
   >            _idx++;
   >    }
   >    bool ConcreteIterator::IsDone() {
   >        return (_idx == _ag->GetSize());
   >    }
   >    //
   >    //  main.cpp
   >    //  Iterator
   >    //
   >    //  Created by NL on 2017/8/27.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Iterator.hpp"
   >    #include "Aggregate.hpp"
   >    using namespace std;
   >    int main(int argc, const char * argv[]) {
   >        Aggregate *ag = new ConcreteAggregate();
   >        Iterator *it = new ConcreteIterator(ag);
   >        for (;!(it->IsDone()); it->Next()) {
   >            cout<<it->CurrentItem()<<endl;
   >        }
   >        return 0;
   >    }
   >    /*
   >    0
   >    1
   >    2
   >    */
   >    ```
   >
   > 3. 代码说明：实际上为了更好的保护Aggregate的状态，我们可以尽量减少Aggregate的接口。

11. Interpreter模式 -解释器模式