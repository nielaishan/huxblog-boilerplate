---
layout:   post
title:    "Webbench"
subtitle: "在路上，，，"
date:     2017-07-24
author:   "NL"
header-img: "img/post-bg-2015.jpg"
tags:
    - c++
---

1. 当一个用户进程被创建的时候，系统会该进程创建三个数据流：标准输出stdin、标准输入stdout、标准错误stderr。

2. fprintf、printf、sprintf

   >1. printf就是标准输出。
   >
   >2. sprintf就是把格式化的数据写入到某个字符串中，返回值：字符串的长度
   >
   >3. fprintf是用于文件操作。
   >
   >   原型：int fprintf(FILE *stream, char *format, [argument]);
   >
   >   功能：fprintf函数根据指定的format（格式）发送信息到由stream指定的文件。因此fprintf可以使得信息输出到指定的文件。

3. 在默认情况下，stdout是行缓冲，他的输出会放在一个buffer中，只有到换行的时候，才会输出到屏幕上。而stderr是无缓冲的，会直接输出。

   ```c++
   int main() {
     fprintf(stdout, "Hello ");
     fprintf(stderrr, "World!");
     return 0;
   }

   /*
   	输出：
   	World!Hello
   	行缓冲：通常只有遇到换行符时，才会执行实际的I/O操作；但缓冲区满也会强制执行。
   	行缓冲输出情况：
   		1. 遇到换行符
   		2. 缓冲区满
   		3. 刷出数据（fflush）
   		4. 关闭文件（fclose）
   */
   ```

4. getopt_long()函数：解析命令行参数

   > int getopt_long(int argc, char * const argv[], const char *optstring,const struct option *longopts, int *longindex);
   >
   > struct option {
   >
   > ​	const char *name;   //选项名，前面没有短横线。
   >
   > ​	int has_arg; 
   >
   > ​	int *flag;
   >
   > ​	int val;
   >
   > };
   >
   > 1. **const char *name**：选项名，前面没有短横线。譬如"help"、"verbose"之类。
   >
   > 2. **int has_arg**：描述长选项是否有选项参数，如果有，是哪种类型的参数，其值见下表:
   >
   >    符号常量             数值            含义
   >    no_argument            0            选项没有参数
   >    required_argument      1            选项需要参数
   >    optional_argument      2            选项参数是可选的
   >
   > 3. **int *flag**：
   >
   >    如果该指针为NULL，那么getopt_long返回val字段的值；如果该指针不为NULL，那么会使得它所指向的结构填入val字段的值，同时getopt_long返回0
   >
   > 4. **int val**：
   >
   >    如果flag是NULL，那么val通常是个字符常量，如果短选项和长选项一致，那么该字符就应该与optstring中出现的这个选项的参数相同；
   >
   > 5. **对于options类型参数可以有两种方式**：
   >
   >    1. 短选项（short options）:顾名思义，就是短小参数。它们通常包含一个连字号和一个字母（大写
   >
   >       或小写字母）。例如：-s，-h等。
   >
   >    2. 长选项（long options）：长选项，包含了两个连字号和一些大小写字母组成的单词。例如，--
   >
   >       size，--help等。    
   >
   >        **注**：一个程序通常会提供包括short options和long options两种参数形式的参数。
   >
   >    3. extern char *optarg;  //选项的参数指针
   >       extern int optind,   //下一次调用getopt的时，从optind存储的位置处重新开始检查选项。 
   >       extern int opterr,  //当opterr=0时，getopt不向stderr输出错误信息。
   >       extern int optopt;  //当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项储在optopt中，getopt返回'?'
   >
   >       ```c++
   >       #include <stdio.h>
   >       #include <stdlib.h>
   >       #include <unistd.h> 
   >       int main(int argc, char **argv)
   >       {
   >           int result; 
   >           opterr = 0;  //使getopt不行stderr输出错误信息 
   >           while( (result = getopt(argc, argv, "ab:c::")) != -1 )
   >           {
   >                  switch(result)
   >                 {
   >                      case 'a':
   >                          printf("option=a, optopt=%c, optarg=%s\n", optopt, optarg);
   >                          break;
   >                     case 'b':
   >                          printf("option=b, optopt=%c, optarg=%s\n", optopt, optarg);
   >                          break;
   >                     case 'c':
   >                          printf("option=c, optopt=%c, optarg=%s\n", optopt, optarg);
   >                          break;
   >                     case '?':
   >                           printf("result=?, optopt=%c, optarg=%s\n", optopt, optarg);
   >                           break;
   >                     default:
   >                          printf("default, result=%c\n",result);
   >                          break;
   >                  }
   >               printf("argv[%d]=%s\n", optind, argv[optind]);
   >           }
   >           printf("result=-1, optind=%d\n", optind);   //看看最后optind的位置 
   >           for(result = optind; result < argc; result++)
   >                printf("-----argv[%d]=%s\n", result, argv[result]); 
   >        //看看最后的命令行参数，看顺序是否改变了哈。
   >           for(result = 1; result < argc; result++)
   >                 printf("\nat the end-----argv[%d]=%s\n", result, argv[result]);
   >           return 0;
   >       } 
   >       //测试：-a ima -b host -c keke -d haha
   >       /*测试结果
   >       option=a, optopt=a, optarg=(null)
   >       argv[2]=ima
   >       result=-1, optind=2
   >       -----argv[2]=ima
   >       -----argv[3]=-b
   >       -----argv[4]=host
   >       -----argv[5]=-c
   >       -----argv[6]=keke
   >       -----argv[7]=-d
   >       -----argv[8]=haha
   >
   >       at the end-----argv[1]=-a
   >
   >       at the end-----argv[2]=ima
   >
   >       at the end-----argv[3]=-b
   >
   >       at the end-----argv[4]=host
   >
   >       at the end-----argv[5]=-c
   >
   >       at the end-----argv[6]=keke
   >
   >       at the end-----argv[7]=-d
   >
   >       at the end-----argv[8]=haha
   >       */
   >       ```
   >
   >       ​

5. 管道通信

   ```c++
   #include<unistd.h>
   int pipe(int fd[2]);
   /*
   	为父子进程间提供一个单向的数据流
   	半双工
   */
   ```

6. [volatile理解](http://hedengcheng.com/?p=725)

7. [static函数](http://www.jb51.net/article/74830.htm)

   static函数：静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。 

8. char *strrchr(const char *str, char c)函数:找一个字符c在另一个字符串str中末次出现的位置（也就是从str的右侧开始查找字符c首次出现的位置），并返回从字符串中的这个位置起，一直到字符串结束的所有字符。如果未能找到指定字符，那么函数将返回NULL。

9. [HTTP、GET、TRACE、OPTIONS](http://www.cnblogs.com/machao/p/5788425.html)。

   1. OPTIONS方法表明请求想得到请求/响应链上关于此请求里的URI（Request-URI）指定资源的通信选项信息
   2. GET方法意思是获取被请求URI（Request-URI）指定的信息（以实体的格式）
   3. HEAD方法和GET方法一致，除了服务器不能在响应里返回消息主体。HEAD请求响应里HTTP头域里的元信息应该和GET请求响应里的元信息一致
   4. POST 方法被用于请求源服务器接受请求中的实体作为请求资源的一个新的从属物

10. [alarm函数](http://blog.sina.com.cn/s/blog_6a1837e90100uhl3.html)

   alarm也称为闹钟函数，alarm()用来设置信号SIGALRM在经过参数seconds指定的秒数后传送给目前的进程。如果参数seconds为0，则之前设置的闹钟会被取消，并将剩下的时间返回。要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。

