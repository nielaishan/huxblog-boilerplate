---
layout:   post
title:    "C++设计模式"
subtitle: "在路上，，，"
date:     2017-08-24
author:   "NL"
header-img: "img/post-bg-2015.jpg"
tags:
    - C++
---

###创建型模式

1. 工厂模式（factory）

   > 1. 两个主要功能
   >    1. 定义创建对象的接口，封装了对象的创建
   >    2. 使得具体化类的工作延迟到子类中。
   >
   > 2. 代码
   >
   >    ```c++
   >    //product.h
   >
   >    #ifndef _PRODUCT_H_
   >    #define _PRODUCT_H_
   >    class Product {
   >        public :
   >      		virtual ~Product()=0;
   >      	protected:
   >      		Product();
   >      	private:
   >      		
   >    };
   >
   >    class ConcreteProduct: public Product {
   >        public:
   >      		~ConcreteProduct();
   >      		ConcreteProduct();
   >      	protected:
   >      	private:
   >    };
   >    #endif 
   >
   >    //Product.cpp
   >    #include<iostream>
   >    using namespace std;
   >
   >    Product::Product() {
   >    }
   >
   >    Product::~Product() {
   >    }
   >
   >    ConcreteProduct::ConcreteProduct() {
   >    }
   >
   >    ConcreteProduct::~ConcreteProduct() {
   >    }
   >
   >    //Factory.h
   >
   >    #ifndef _FACTORY_H_
   >    #define _FACTORY_H_
   >
   >    class Product;  //声明
   >
   >    class Factory {
   >        public:
   >      		virtual ~Factory()=0;
   >    	    virtual Product* CreateProduct()=0;
   >      	protected:
   >      		Factory();
   >    };
   >
   >    class ConcreteFactory:public Factory {
   >     	public:
   >      		~ConcreteFactory();
   >      		ConcreteFactory();
   >      		Product *CreateProduct();
   >    };
   >    #endif
   >
   >    //Factory.cpp
   >    #include"Factory.h"
   >    #include"Product.h"
   >    #include<iostream>
   >    using namespace std;
   >    Factory::Factory() {}
   >    Factory()~Factory() {}
   >
   >    ConcreteFactory::ConcreteFactory() {}
   >    ConcreteFactory::~ConcreteFactory() {}
   >    Product* ConcreteFactory::CreateProduct() {
   >        return new ConcreteProduct();
   >    }
   >
   >    //main.cpp
   >    #include"Product.h"
   >    #include"Factory.h"
   >    #include<iostream>
   >    using namespace std;
   >
   >    int main() {
   >        Factory *fac = new ConcreteFactory();
   >      	Product *p = fac->CreateProduct();
   >      	return 0;
   >    }
   >    ```

2. AbstractFactory模式

   > 1. 它主要解决：要创建一组相关或者相互依赖的对象
   >
   > 2. ```c++
   >    //Product.h
   >    class AbstractProductA {
   >        public:
   >      		virtual ~AbstractProductA();
   >      	protected:
   >      		AbstractProductA();
   >    };
   >
   >    class AbstractProductB {
   >        public:
   >      		virtual ~AbstractProductB();
   >      	protected:
   >      		AbstractProductB();
   >    };
   >
   >    class ProductA1:public AbstractProductA{
   >        public:
   >      		ProductA1();
   >      		~ProductA1();
   >    };
   >
   >    class ProductA2:public AbstractProductA{
   >        public:
   >      		ProductA2();
   >      		~ProductA2();
   >    };
   >
   >    class ProductB1:public AbstractProductB{
   >        public:
   >      		ProductB1();
   >      		~ProductB1();
   >    };
   >
   >    class ProductB2:public AbstractProductB{
   >        public:
   >      		ProductB2();
   >      		~ProductB2();
   >    };
   >    #endif
   >    //Product.cpp
   >    #include"Product.h"
   >    #include<iostream>
   >    using namespace std;
   >    AbstractProductA::AbstractProductA(){}
   >    AbstractProductA::~AbstractProductA(){}
   >    AbstractProductB::AbstractProductB(){}
   >    AbstractProductB::~AbstractProductB(){}
   >    ProductA1::ProductA1() {
   >        cout<<"P A1"<<endl;
   >    }
   >    ProductA1::~ProductA1(){}
   >    ProductA2::ProductA2() {
   >        cout<<"P A2"<<endl;
   >    }
   >    ProductA2::~ProductA2(){}
   >
   >    ProductB1::ProductB1() {
   >        cout<<"P B1"<<endl;
   >    }
   >    ProductB1::~ProductB1(){}
   >    ProductB2::ProductB2() {
   >        cout<<"P B2"<<endl;
   >    }
   >    ProductB2::~ProductB2(){}
   >
   >    //AbstractFactory.h
   >    #ifndef _ABSTRACTFACTORY_H_
   >    #define _ABSTRACTFACTORY_H_
   >    class AbstractProductA;
   >    class AbstractProductB;
   >    class AbstractFactory {
   >        public:
   >      		virtual ~AbstractFactory();
   >      		virtual AbstractProductA *CreateProductA()=0;
   >      		virtual AbstractProductB *CreateProductB()=0;
   >      	protected:
   >      		AbstractFactory();
   >    };
   >
   >    class CreateFactory1::public AbstractFactory{
   >        public:
   >      		ConcreteFactory1();
   >      		~ConcreteFactory1();
   >      		AbstractProductA *CreateProductA();
   >      		AbstractProductB *CreateProductB();
   >    };
   >
   >    class CreateFactory2::public AbstractFactory{
   >        public:
   >      		ConcreteFactory2();
   >      		~ConcreteFactory2();
   >      		AbstractProductA *CreateProductA();
   >      		AbstractProductB *CreateProductB();
   >    };
   >    #endif
   >
   >    //AbstractFactory.cpp
   >    #include"Product.h"
   >    #include"AbstractFactory.h"
   >    #include<iostream>
   >    using namespace std;
   >    AbstractFactory::AbstractFactory() {}
   >    AbstractFactory::~AbstractFactory() {}
   >    ConcreteFactory1::ConcreteFactory1(){}
   >    ConcreteFactory1::~ConcreteFactory1(){}
   >    AbstractProductA *ConcreteFactory1::createProductA(){
   >        return new ProductA1();
   >    }
   >    AbstractProductB *ConcreteFactory1::createProductA(){
   >        return new ProductB1();
   >    }
   >    ConcreteFactory2::ConcreteFactory2(){}
   >    ConcreteFactory2::~ConcreteFactory2(){}
   >    AbstractProductA *ConcreteFactory2::createProductA(){
   >        return new ProductA2();
   >    }
   >    AbstractProductB *ConcreteFactory2::createProductA(){
   >        return new ProductB2();
   >    }
   >
   >    //main.cpp
   >    #include"AbstracrFactory"
   >    #include"AbstractProduct.h"
   >    #include<iostream>
   >    using namespace std;
   >    int main() {
   >        AbstractFactory* cf1 = new ConcreteFactory1();
   >      	cf1->CreateProductA();
   >      	cf1->CreateProductB();
   >      	AbstractFactory* cf2 = new ConcreteFactory2();
   >      	cf2->CreateProductA();
   >      	cf2->CreateProductB();
   >    }
   >    /*
   >    	当我创建一组对象（product1， product2）的时候我们只用维护一个创建对象ConcreteFactory，大大简化了维护的成本和工作
   >    */
   >    ```
   >
   > 3. AbstractFactory和Factory的区别：AbstractFactory模式是为创建一组相关或依赖的对象提供创建接口。而Factory模式是为一类对象提供接口或延迟对象的创建到子类中实现

3. Singleton模式

   > 1. 解决问题：我们怎样去创建一个唯一的变量（对象）？
   >
   > 2. 在Singleton模式的结构图中可以看到，我们通过维护一个static的成员变量来记录这个唯一的对象实例。通过提供一个static的接口instance来获得这个唯一的实例。
   >
   > 3. 代码
   >
   >    ```c++
   >    //Singleton.h
   >    #ifndef _SINGLETON_H_
   >    #define _SINGLETON_H_
   >    #include<iostream>
   >    using namespace std;
   >    class Singleton {
   >        public:
   >      		static Singleton* Instance();
   >      	protected:
   >      		Singleton();
   >      	private:
   >      		static Singleton* _instance();
   >    };
   >    #endif
   >    //Singleton.cpp
   >    #include"Singleton.h"
   >    #include<iostream>
   >    using namespace std;
   >    Singleton *Singleton::_instance = 0; //static定义
   >    Singleton::Singleton() {
   >        cout<<"Singleton"<<endl;
   >    }
   >    Singleton* Singleton::Instance() {
   >        if (_instance == 0)
   >          _instance = new Singleton();
   >      	return _instance;
   >    }
   >    //main.cpp
   >    #include"Singleton.h"
   >    #include<iostream>
   >    using namespace std;
   >    int main() {
   >        Singleton* sgn = Singleton::Instance();
   >     	return 0;
   >    }
   >    /*
   >    	代码说明：
   >    		Singleton模式的实现无须补充解释，需要说明的是，Singleton不可以被实例化，因此我们将构造函数声明为protected或者直接声明private。
   >    */
   >    ```

4. Builder模式--对象创建型模式

   > 1. 解决问题：当我们要创建的对象很复杂的时候（通常是由很多其他对象组合而成），我们要复杂对象的创建过程和这个对象的表示分离开来，这样做的好处就是一步步的进行复杂对象的构建，由于在每一步的构造过程中可以引入参数，使得经过相同的步骤创建最后得到的对象的展示不一样。
   >
   > 2. 代码:
   >
   >    ```c++
   >    Product
   >
   >    /************************************************************************
   >     * Product Controls                                                     *
   >     ***********************************************************************/
   >
   >    /***********************************************
   >     * Class Frame                                 *
   >     **********************************************/
   >    class Frame
   >    {
   >    public:
   >        virtual void draw() = 0;
   >    };
   >
   >    /***********************************************
   >     * Class Title                                 *
   >     **********************************************/
   >    class Title : public Frame
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"title draw"<<endl;
   >        }
   >    };
   >
   >    class TextTitle: public Title
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"TextTitle draw"<<endl;
   >        }
   >    };
   >
   >    class ImageTitle: public Title
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"ImageTitle draw"<<endl;
   >        }
   >    };
   >
   >    /***********************************************
   >     * Class Menu                                  *
   >     **********************************************/
   >    class Menu : public Frame
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"menu draw"<<endl;
   >        }
   >    };
   >
   >    class ListMenu: public Menu
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"ListMenu draw"<<endl;
   >        }
   >    };
   >
   >    class ThreeDMenu: public Menu
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"3DMenu draw"<<endl;
   >        }
   >    };
   >
   >    /***********************************************
   >     * Class Toolbar                               *
   >     **********************************************/
   >    class Toolbar : public Frame
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"Toolbar draw"<<endl;
   >        }
   >    };
   >
   >    class CellToolbar : public Toolbar
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"CellToolbar draw"<<endl;
   >        }
   >    };
   >
   >    class FloatToolbar : public Toolbar
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"FloatToolbar draw"<<endl;
   >        }
   >    };
   >
   >    /***********************************************
   >     * Class Button                                *
   >     **********************************************/
   >    class Button : public Frame
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"Button draw"<<endl;
   >        }
   >    };
   >
   >    class TextButton : public Button
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"TextButton draw"<<endl;
   >        }
   >    };
   >
   >    class ImageButton : public Button
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"CellToolbar draw"<<endl;
   >        }
   >    };
   >
   >    class ThreeDButton : public Button
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            cout<<"ThreeDButton draw"<<endl;
   >        }
   >    };
   >
   >    /***********************************************
   >     * Class Page                                  *
   >     **********************************************/
   >    class Page : public Frame
   >    {
   >    public:
   >        #define FRAME_MAX   10
   >
   >        Page()
   >        {
   >            m_frame_num = 0;
   >        }
   >
   >        void AddFrame(Frame* frm)
   >        {
   >            if (m_frame_num < FRAME_MAX)
   >            {
   >                m_frame[m_frame_num] = frm;
   >                m_frame_num++;
   >            }
   >        }
   >        virtual void draw()
   >        {
   >            cout<<"page draw"<<endl;
   >            for (int i =0; i < m_frame_num; i++)
   >            {
   >                m_frame[i]->draw();
   >            }
   >        }
   >    private:
   >        Frame* m_frame[FRAME_MAX];
   >        int m_frame_num;
   >    };
   >
   >    class SlidePage : public Page
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            Page::draw();
   >            cout<<"SlidePage draw"<<endl;
   >        }
   >    };
   >
   >    class VaryPage : public Page
   >    {
   >    public:
   >        virtual void draw()
   >        {
   >            Page::draw();
   >            cout<<"VaryPage draw"<<endl;
   >        }
   >    };
   >
   >    Builder
   >    /************************************************************************
   >     * Build ControlBuilder                                                 *
   >     ***********************************************************************/
   >
   >    /***********************************************
   >     * Class ControlBuilder                        *
   >     **********************************************/
   >    class ControlBuilder
   >    {
   >    protected:
   >        ControlBuilder(){}
   >    public:
   >        virtual void BuildTitle()   {   }
   >        virtual void BuildMenu()    {   }
   >        virtual void BuildToolbar() {   }
   >        virtual void BuildButton()  {   }
   >        virtual void BuildPage()    {   }
   >        
   >        virtual Page* GetPage()     {return NULL;}
   >    };
   >
   >    /***********************************************
   >     * Class GenerralControlBuilder                *
   >     **********************************************/
   >    class GenerralControlBuilder: public ControlBuilder
   >    {
   >    public:
   >        virtual void BuildTitle()
   >        {
   >            Title* tl = new TextTitle();
   >            m_page->AddFrame(tl);
   >        }
   >        virtual void BuildMenu()
   >        {
   >            Menu* mu =  new ListMenu();
   >            m_page->AddFrame(mu);
   >        }
   >        virtual void BuildToolbar()
   >        {
   >            Toolbar* tb =  new CellToolbar();
   >            m_page->AddFrame(tb);
   >        }
   >        virtual void BuildPage()
   >        {
   >            m_page =  new SlidePage();
   >        }
   >
   >        virtual Page* GetPage()
   >        {
   >            return m_page;
   >        }
   >    private:
   >        Page* m_page;
   >    };
   >
   >    /***********************************************
   >     * Class MagicControlBuilder                   *
   >     **********************************************/
   >    class MagicControlBuilder: public ControlBuilder
   >    {
   >    public:
   >        MagicControlBuilder()
   >        {
   >            m_page = NULL;
   >        }
   >
   >        virtual void BuildTitle()
   >        {
   >            Title* tl =  new ImageTitle();
   >            m_page->AddFrame(tl);
   >        }
   >        virtual void BuildMenu()
   >        {
   >            Menu* mu = new ThreeDMenu();
   >            m_page->AddFrame(mu);
   >        }
   >        virtual void BuildToolbar()
   >        {
   >            Toolbar* tb = new FloatToolbar();
   >            m_page->AddFrame(tb);
   >        }
   >        virtual void BuildButton()
   >        {
   >            Button* btn = new ThreeDButton();
   >            m_page->AddFrame(btn);
   >        }
   >        virtual void BuildPage()
   >        {
   >            m_page =  new VaryPage();
   >        }
   >        virtual Page* GetPage()
   >        {
   >            return m_page;
   >        }
   >    private:
   >        Page* m_page;
   >    };
   >    Director
   >    /************************************************************************
   >     * Director PageDirector                                                *
   >     ***********************************************************************/
   >
   >    /***********************************************
   >     * Class PageDirector                          *
   >     **********************************************/
   >    class PageDirector
   >    {
   >    public:
   >        PageDirector(ControlBuilder* builder)
   >        {
   >            m_builder = builder;
   >        }
   >        virtual Page* CreatePage()
   >        {
   >            m_builder->BuildPage();
   >            m_builder->BuildTitle();
   >            m_builder->BuildMenu();
   >            m_builder->BuildToolbar();
   >            m_builder->BuildButton();
   >
   >            return m_builder->GetPage();
   >        }
   >    private:
   >        ControlBuilder* m_builder;
   >    };
   >
   >    Director
   >
   >    /************************************************************************
   >     * Director PageDirector                                                *
   >     ***********************************************************************/
   >
   >    /***********************************************
   >     * Class PageDirector                          *
   >     **********************************************/
   >    class PageDirector
   >    {
   >    public:
   >        PageDirector(ControlBuilder* builder)
   >        {
   >            m_builder = builder;
   >        }
   >        virtual Page* CreatePage()
   >        {
   >            m_builder->BuildPage();
   >            m_builder->BuildTitle();
   >            m_builder->BuildMenu();
   >            m_builder->BuildToolbar();
   >            m_builder->BuildButton();
   >
   >            return m_builder->GetPage();
   >        }
   >    private:
   >        ControlBuilder* m_builder;
   >    };
   >    ```
   >
   > 3. Builder和AbstractFactory模式的区别：Builder模式强调的是一步步创建对象，并通过相同的创建过程可以获得不同的结构对象，一般来说builder模式对象不是直接返回的。而在AbstractFactory模式中对象是直接返回的，它强调的是为创建相互依赖的对象提供一个同一的接口。

5. Prototype模式-原型模式

   > 1. Prototype模式也正是提供自我复制的功能，就是说新对象的创建可以通过已有对象进行创建。
   >
   > 2. Prototype模式提供了一个通过已存在的对象进行新对象创建的接口（clone）。在C++中我们将通过拷贝构造函数实现。
   >
   >    ```c++
   >    //Prototype.h
   >    #ifndef _PROTOTYPE_H_
   >    #define _PROTOTYPE_H_
   >    class Prototype {
   >      	public:
   >      		virtual ~Prototype();
   >    	  	virtual Prototype* Clone() const = 0;
   >      	protected:
   >      		Prototype();
   >    };
   >
   >    class ConcretePrototype:public Prototype {
   >        public:
   >      		~ConcretePrototype();
   >      		ConcretePrototype();
   >      		ConcretePrototype(const ConcreteProtype &cp);
   >      		Prototype* Clone() const;
   >    }
   >    #endif
   >    //Prototype.cpp
   >    #include"Prototype.h"
   >    #include<iostream>
   >    using namespace std;
   >    Prototype::Prototype() {}
   >    Prototype::~Prototype() {}
   >    Prototype* Prototype::Clone() const {
   >        return 0;
   >    }
   >    ConcretePrototype::ConcretePrototype() {
   >    }
   >    ConcretePrototype::~ConcretePrototype() {
   >    }
   >    ConcretePrototype::ConcretePrototype(const ConcretePrototype &cp) {
   >      cout<<"COncretePrototype copy"<<endl;
   >    }
   >
   >    Prototype* ConcretePrototype::Clone() const {
   >        return new ConcretePrototype(*this);
   >    }
   >    //main.cpp
   >    #include"Prototype.h"
   >    #include<iostream>
   >    using namespace std;
   >    int main() {
   >        Prototype *p = new ConcrePrototype();
   >      	Prototype *p1 = p->Clone();  //拷贝构造函数实现
   >      	return 0;
   >    }
   >    ```
   >
   > 3. 实际上Prototype模式和builder模式、AbstractFactory模式都是通过一个类来专门负责对象的茶创建工作。它们之间的区别是：builder模式重在复杂对象的一步步创建，AbstractFactory模式重在产生多个相互依赖类的对象，而Prototype模式在从自身复制自己创建新类。

   ### 结构型设计模式。

   1. Bridge模式-桥接模式

      > 1. 面向对象设计追求的两点：1、松耦合，2、高内聚。尽可能地提供系统模块内部的内聚、尽可能降低模块间的耦合。
      >
      > 2.  作用：将抽象部份与它的实现部份分离，使它们都可以独立地变化。将抽象(Abstraction)与实现(Implementation)分离，使得二者可以独立地变化。桥接模式号称设计模式中最难理解的模式之一，关键就是这个抽象和实现的分离非常让人奇怪，大部分人刚看到这个定义的时候都会认为实现就是继承自抽象，那怎么可能将他们分离呢。
      >
      >    ```c++
      >    //Abstraction.h
      >    #ifndef _ABSTRACT_H_
      >    #define _ABSTRACT_H_
      >    class AcstractionImp;
      >
      >    class Abstraction {
      >        pubic:
      >      		virtual ~Abstraction();
      >      		virtual void Operation() = 0;
      >      	protected:
      >      		Abstraction();
      >    };
      >
      >    class RefinedAbstraction:public Abstraction{
      >        public:
      >      		RefinedAbstraction(AbstractionImp *imp);
      >      		～RefinedAbstraction();
      >      		void Operation();
      >      	private:
      >      		AbstractionImp *_imp;
      >    }；
      >    #endif
      >    //Abstraction.cpp
      >    #include"Abstraction.h"
      >    #include<iostream>
      >    #include"AbstractionImp.h"
      >    using namespace std;
      >    Abstraction::Abstraction() {}
      >    Abstraction::~Abstractione(){}
      >    RefinedAbstraction::RefinedAbstraction(AbstracionImp *imp) {
      >        _imp = imp;
      >    }
      >    RefinedAbstraction::~RefinedAbstraction(){}
      >    void RefinedAbstraction::Operation() {
      >        _imp->Operation();
      >    }
      >    //AbstractionImp.h
      >    #ifndef _ABSTRACTIONIMP_H_
      >    #define _ABSTRACTIONIMP_H_
      >    class AbstractionImp{
      >        public :
      >      		virtual ~AbstractionImp();
      >      		virtual void Operation();
      >      	protected:
      >      		AbstractionImp();
      >    };
      >    class ConcreteAbstraionImpA:public AbstractionImp{
      >        public:
      >      		ConcreteAbstractionA();
      >      		~ConcreteAbstractionImpA();
      >      		virtual void Operation();
      >    };
      >    class ConcreteAbstraionImpB:public AbstractionImp{
      >        public:
      >      		ConcreteAbstractionB();
      >      		~ConcreteAbstractionImpB();
      >      		virtual void Operation();
      >    };
      >    #endif
      >    //AbstractionImp.cpp
      >    #include"AbstractionImp.h"
      >    #include<iostream>
      >    using namespace std;
      >    AbstractionImp::AbstractionImp(){}
      >    AbstractionImp::~AbstractionImp(){}
      >    void AbstractionImp::Operation() {
      >        cout<<"AbstractionImp imp"<<endl;
      >    }
      >
      >    ConcreteAbstractionImpA::ConcreteAbstractionImpA() {}
      >    ConcreteAbstractionImpA::~ConcreteAbstractionImpA() {}
      >    void ConcreteAbstractionImpA::Operation() {
      >        cout<<"ConcreteAbstractionImpA operation"<<endl;
      >    }
      >    ConcreteAbstractionImpB::ConcreteAbstractionImpB() {}
      >    ConcreteAbstractionImpB::~ConcreteAbstractionImpB() {}
      >    void ConcreteAbstractionImpB::Operation() {
      >        cout<<"ConcreteAbstractionImpB operation"<<endl;
      >    }
      >    //main.cpp
      >    #include"Abstraction.h"
      >    #include"AbstractioncImp.h"
      >    #include<iostream>
      >    using namespace std;
      >    int main() {
      >        AbstractionImp* imp = new ConcreteAbstractionImpA();
      >      	Abstraction* abs = new RefinedAbstracion(imp);
      >      	abs->Operation();
      >      	return 0;
      >    }
      >    /*
      >    	Bridge模式将抽象和实现分别独立实现，在代码就是Abstraction类和AbstractionImp类
      >    */
      >    ```
      >
      > 3. （1）.客户给了你一个需求，于是使用一个类来实现（A）； 
      >
      >    （2）.客户需求变化，有两个算法实现功能，于是改变设计，我们通过一个抽象的基类，再定义两个具体类实现两个不同的算法（A1和A2）； 
      >
      >    （3）.客户又告诉我们说对于不同的操作系统，于是再抽象一个层次，作为一个抽象基类A0，在分别为每个操作系统派生具体类（A00和A01，其中A00表示原来的类A）实现不同操作系统上的客户需求，这样我们就有了一共4个类。
      >
      >    （4）.可能用户的需求又有变化，比如说又有了一种新的算法…….. 
      >
      >    （5）.我们陷入了一个需求变化的郁闷当中，也因此带来了类的迅速膨胀。
      >
      >    Bridge模式则正是解决了这类问题。

   2. Adapter模式-适配器模式

      > 1. 对应于Adapter模式的两种类别：类模式和对象模式
      >
      > 2. 作用：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
      >
      >    ```c++
      >    //Adapter.h
      >    #ifndef _ADAPTER_H_
      >    #define _ADAPTER_H_
      >
      >    //目标接口类，客户需要的接口
      >    class Target
      >    {
      >    public:
      >        Target();
      >        virtual ~Target();
      >        virtual void Request();//定义标准接口
      >    };
      >
      >    //需要适配的类
      >    class Adaptee
      >    {
      >    public:
      >        Adaptee();
      >        ~Adaptee();
      >        void SpecificRequest();
      >    };
      >    //类模式，适配器类，通过public继承获得接口继承的效果，通过private继承获得实现继承的效果
      >    class Adapter:public Target,private Adaptee
      >    {
      >    public:
      >        Adapter();
      >        ~Adapter();
      >        virtual void Request();//实现Target定义的Request接口
      >    };
      >
      >    //对象模式，适配器类，继承Target类，采用组合的方式实现Adaptee的复用
      >    class Adapter1:public Target
      >    {
      >    public:
      >        Adapter1(Adaptee* adaptee);
      >        Adapter1();
      >        ~Adapter1();
      >        virtual void Request();//实现Target定义的Request接口
      >    private:
      >        Adaptee* _adaptee;
      >    };
      >    #endif
      >    //Adapter.cpp
      >    #include "Adapter.h"
      >    #include <iostream>
      >
      >    using namespace std;
      >    Target::Target()
      >    {}
      >    Target::~Target()
      >    {}
      >    void Target::Request()
      >    {
      >        cout << "Target::Request()" << endl;
      >    }
      >    Adaptee::Adaptee(){
      >    }
      >    Adaptee::~Adaptee(){
      >    }
      >    void Adaptee::SpecificRequest(){
      >        cout << "Adaptee::SpecificRequest()" << endl;
      >    }
      >    //类模式的Adapter
      >    Adapter::Adapter(){
      >    }
      >    Adapter::~Adapter(){
      >    }
      >    void Adapter::Request(){
      >        cout << "Adapter::Request()" << endl;
      >        this->SpecificRequest();
      >        cout << "----------------------------" <<endl;
      >    }
      >    //对象模式的Adapter
      >    Adapter1::Adapter1():_adaptee(new Adaptee){
      >    }
      >    Adapter1::Adapter1(Adaptee* _adaptee){
      >        this->_adaptee = _adaptee;
      >    }
      >    Adapter1::~Adapter1(){
      >    }
      >    void Adapter1::Request(){
      >        cout << "Adapter1::Request()" << endl;
      >        this->_adaptee->SpecificRequest();
      >        cout << "----------------------------" <<endl;
      >    }
      >    //main.cpp
      >    #include "Adapter.h"
      >    #include<iostream>
      >    using namespace std;
      >    int main()
      >    {
      >        //类模式Adapter
      >        Target* pTarget = new Adapter();
      >        pTarget->Request();
      >
      >        //对象模式Adapter1
      >        Adaptee* ade = new Adaptee();
      >        Target* pTarget1= new Adapter1(ade);
      >        pTarget1->Request();
      >
      >        //对象模式Adapter2
      >        Target* pTarget2 = new Adapter1();
      >        pTarget2->Request();
      >
      >        return 0;
      >    }
      >    /*
      >    	在类模式中，我们通过private继承adaptee获得实现继承的效果，而通过public继承target获得接口继承的效果
      >    */
      >    ```
      >
      > 3. 理解：为了调用第三方库的方法，实现该类的本方法
      >
      > 4. 讨论：在C++的public继承既是接口继承又是实现继承，因为子类在继承了父类后既可以对外提供父类的接口操作，又可以获得父类的接口实现。当我们用private继承时，子类只是继承了实现继承的效果。

   3. Decorator模式-装饰模式

      > 1. 问题在OO设计和开发过程中，我们需要为一个已经定义好的类添加新的职责，通常的情况我们会给定义一个新类继承自定义的类，这样会带来一个问题。通过继承的方式解决这样的问题还带来了系统的复杂性，因为继承的深度会变得很深。而decorator提供了一种给类增加职责的方法，不是通过继承实现的，而是通过组合。
      >
      >    ```c++
      >    //Decorator.h
      >    #ifndef _DECORATOR_H_
      >    #define _DECORATOR_H_
      >    class Component {
      >      	public:
      >      		virtual ~Component();
      >      		virtual void Operation();
      >      	protected:
      >      		Component();
      >    };
      >    class ConcreteComponent:public Component {
      >        public:
      >      		~ConcreteComponent();
      >      		ConcreteComponent();
      >      		void Operation();
      >    };
      >
      >    class Decorator:public Component {
      >        public:
      >      		Decortor(Component* com);
      >      		virtual ~Decortor();
      >      		virtual void Operation();
      >      	protected:
      >      		Component* _com;
      >    };
      >    class ConcreteDecorator:public Decorator{
      >        public:
      >      		ConcreteDecorator(Component *com);
      >      		~ConcreteDecorator();
      >      		void Operation();
      >      		void AddedBehavior();
      >    };
      >    #endif
      >    //Decorator.cpp
      >    #include"Decorator.h"
      >    #include<iostream>
      >    using namespace std;
      >    Component::Component(){}
      >    Component::~Component(){}
      >    ConcreteComponent::ConcreteComponent(){}
      >    ConcreteComponent::~ConcreteComponent(){}
      >    void ConcreteComponent::Operation() {
      >        cout<<"ConcreteComponent operation"<<endl;
      >    }
      >    Decorator::Decorator(Component *com){
      >       this-> _com = com;
      >    }
      >    Decorator::~Decorator(){
      >        delete _com;
      >    }
      >    ConcreteDecorator::ConcreteDecorator(Component *com):Decorator(com) {} 
      >    ConcreteDecorator::~ConcreteDecorator(){}
      >    void ConcreteDecorator::Operation() {
      >        _com->Operation();
      >      	this->Addedhavior();
      >    }
      >    void ConcreteDecortor::Addedhavior() {
      >        cout<<"ConcreteDecorator Operation"<<endl;
      >    }
      >    //main.cpp
      >    #include"Decorator.h"
      >    #include<iostream>
      >    using namespace std;
      >    int main() {
      >        Component *com = new ConcreteComponent();
      >    	Decortor *d = new ConcreteDecorator(com);
      >      	d->Operation();
      >      	delete d;
      >      	return 0;
      >    }
      >    /*
      >    	ConcreteDecorator给ConcreteComponent类添加了addedhavior操作。
      >    */
      >    ```
      >
      > 2. Decorator模式和Proxy模式相似的地方在于它们都拥有一个指向其他对象的引用，即通过组合的方式来为对象提供更多的操作；但是他们的区别是Proxy模式会提供实用作为代理的对象一样的接口，使用代理类将其操作委托给 Proxy直接进行。这里可以简单理解为组合和委托的微妙的区别了。

   4. Composite模式-组合模式

      > 1. 问题：在开发中，我们经常可能要递归构建树状的组合结构，Composite模式提供了很好的解决方案。
      >
      > 2. 组合模式的使用场景
      >
      >    1. 当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。
      >    2. 基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了。
      >    3. 用户不用关心到底是处理一个叶节点还是处理一个组合组件，也就用不着为定义组合二写一些选择判断语句了。
      >    4. 组合模式让客户可以一致地使用组合结构和单个对象。
      >
      > 3. 接口函数
      >
      >    1. Component::Operatation:定义了各个组件共有的行为接口，由各个组件的具体实现.
      >    2. Component::Add添加一个子组件。
      >    3. Component::Remove删除一个子组件。
      >    4. Component::GetChild获得子组件的指针
      >
      > 4. 说明
      >
      >    1. Leaf是叶子结点也就是不含邮子组件的节点
      >    2. Composite是含有子组件的类
      >
      >    ```c++
      >    //Component.h
      >    #ifndef _COMPONENT_H_
      >    #define _COMPONENT_H_
      >    #include<vector>
      >    using namespace std;
      >    class Component{
      >        public:
      >      		virtual void Operation()=0;
      >      		virtual void Add(Component *);
      >      		virtual void Remove(Component *);
      >      		virtual Component* GetChild(int index);
      >      		virtual ~Component();
      >      	protected:
      >      		Component();
      >    };
      >    class Leaf:public Component{
      >        public:
      >      		virtual void Operation();
      >      		Leaf();
      >      		~Leaf();
      >    };
      >
      >    class Composite:public Component {
      >        public:
      >      		Component();
      >      		~Component();
      >      		void Operation();
      >      		void Add(Component *);
      >      		void Remove(Component *);
      >      		Component *GetChild(int index);
      >      	private:
      >      		vector<Component *>m_ComVec;
      >    };
      >    #endif
      >    //Component.cpp
      >    #include"Component.h"
      >    #include<iostream>
      >    using namespace std;
      >    Component::Component(){}
      >    Component::~Component() {}
      >    void Component::Add(Component* com){
      >        cout << "add" << endl;
      >    }
      >    void Component::Remove(Component* com){
      >    }
      >    void Component::Operation(){
      >        cout << "Component::Operation" << endl;
      >    }
      >    Component* Component::GetChild(int index){
      >        return NULL;
      >    }
      >    Leaf::Leaf(){}
      >    Leaf::~Leaf(){}
      >    void Leaf::Operation(){
      >        cout<<"Leaf::op"<<endl;
      >    }
      >    Composite::Composite(){}
      >    Composite::~Composite(){}
      >    void Composite::Add(Component *com) {
      >        this->m_ComVec.push_back(com);
      >    }
      >    void Composite::Remove(Component *com) {
      >        this->m_ComVec.erase(&com);
      >    }
      >    void Composite::Operation(){
      >        cout << "Composite::Operation" << endl;
      >        vector<Component*>::iterator iter = this->m_ComVec.begin();
      >        for(;iter!= this->m_ComVec.end();iter++){
      >            (*iter)->Operation();
      >        }
      >    }
      >    Component* Composite::GetChild(int index){
      >        if(index < 0 || index > this->m_ComVec.size()){
      >            return NULL;
      >        }
      >        return this->m_ComVec[index];
      >    }
      >    //main.cpp
      >    #include"Composite.h"
      >    #include<iostream>
      >    using namespace std;
      >    int main() {
      >        Composite *pRoot = new Composite();
      >      	pRoot->add(new Leaf());
      >      	Leaf *pLeaf1 = new Leaf();
      >      	Leaf *pLeaf2 = new Leaf();
      >      	Composite *pCom = new Composite(); //组合对象
      >      	pCom->add(pLeaf1); //组合对象添加叶子结点
      >      	pCom->add(pLeaf2);
      >      	pCom->Operation(); //执行组合对象Oparation操作
      >      	pRoot->Add(pCom);
      >      	pRoot->Operation();
      >      	return 0;
      >    }
      >    ```
      >
      > 5. 讨论：Composite模式和Decorator模式有着类似的结构图，但是Composite模式旨在构造类，而Decorator模式重在不生成子类即可给对象添加职责。Decorator模式重在修饰，composite模式重在表示

   5. Flyweight模式-享元模式

      > 1. 作用：运用共享技术有效地支持大量细粒度的对象。
      >
      > 2. **内部状态intrinsic和外部状态extrinsic**：
      >
      >    1）Flyweight模式中，最重要的是将对象分解成intrinsic和extrinsic两部分。
      >    2）内部状态：在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态
      >    3）外部状态：而随环境改变而改变的，取决于应用环境，或是实时数据，这些不可以共享的东西就是外部状态了。
      >    4）内部状态和外部状态之间的区别：
      >    　　在Flyweight模式应用中，通常修改的是外部状态属性，而内部状态属性一般都是用于参考或计算时引用。
      >    Flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于ConcreteFlyweight对象之中；而外部状态则由Client对象存储或计算。当用户调用Flyweight对象的操作时，将该状态传递给它。
      >    以文字处理软件为例：
      >
      >    　　内部状态存储于flyweight中，它包含了独立于flyweight场景的信息，这些信息使得flyweight可以被共享。如字符代码，字符大小……
      >
      >    　　外部状态取决于flyweight场景，并根据场景而变化，因此不可共享。用户对象负责在必要的时候将外部状态传递给flyweight，如字符位置，字符颜色……
      >
      >    ```c++
      >    //
      >    //  Flyweight.hpp
      >    //  FlyWeight
      >    //
      >    //  Created by NL on 2017/8/25.
      >    //  Copyright © 2017年 NL. All rights reserved.
      >    //
      >
      >    #ifndef Flyweight_hpp
      >    #define Flyweight_hpp
      >    #include <stdio.h>
      >    #include <string>
      >    #include <vector>
      >    using namespace std;
      >    class Flyweight{
      >    public:
      >        virtual void Operation(const string &extrinsicState)=0;
      >        string GetIntrinsicState();
      >        virtual ~Flyweight();
      >    protected:
      >        Flyweight(string intrinsicState);
      >    private:
      >        string _intrinsciState;
      >    };
      >
      >    class ConcreteFlyweight:public Flyweight {
      >    public:
      >        virtual void Operation(const string &extrinsicState);
      >        ConcreteFlyweight(string );
      >        ~ConcreteFlyweight();
      >    };
      >
      >    class UnsharedConcreteFlyweight:public Flyweight {
      >    public:
      >        virtual void Operation(const string &extrinsicState);
      >        UnsharedConcreteFlyweight(string );
      >        ~UnsharedConcreteFlyweight();
      >    };
      >
      >    class FlyweightFactory{
      >    public:
      >        FlyweightFactory();
      >        ~FlyweightFactory();
      >        //获得一个请求的Flyweight对象
      >        Flyweight* GetFlyweight(string key);
      >        void GetFlyweightCount();
      >    private:
      >        vector<Flyweight*>m_vecFly;
      >    };
      >    #endif /* Flyweight_hpp */
      >    //
      >    //  Flyweight.cpp
      >    //  FlyWeight
      >    //
      >    //  Created by NL on 2017/8/25.
      >    //  Copyright © 2017年 NL. All rights reserved.
      >    //
      >
      >    #include "Flyweight.hpp"
      >    #include <iostream>
      >    #include <vector>
      >    using namespace std;
      >    Flyweight::Flyweight(string intrinsicSate){
      >        this->_intrinsciState = intrinsicSate;
      >    }
      >    Flyweight::~Flyweight(){}
      >    string Flyweight::GetIntrinsicState() {
      >        return this->_intrinsciState;
      >    }
      >    ConcreteFlyweight::ConcreteFlyweight(string intrinsicState):Flyweight(intrinsicState) {
      >    }
      >    ConcreteFlyweight::~ConcreteFlyweight(){}
      >    void ConcreteFlyweight::Operation(const string &extrinsicState){
      >        cout<<this->GetIntrinsicState()<<endl;
      >        cout<<extrinsicState<<endl;
      >    }
      >
      >    UnsharedConcreteFlyweight::UnsharedConcreteFlyweight(string intrinsicState):Flyweight(intrinsicState) {
      >    }
      >
      >    UnsharedConcreteFlyweight::~UnsharedConcreteFlyweight(){}
      >    void UnsharedConcreteFlyweight::Operation(const string &extrinsicState) {
      >        cout<<extrinsicState<<endl;
      >    }
      >    FlyweightFactory::FlyweightFactory(){}
      >    FlyweightFactory::~FlyweightFactory(){}
      >    Flyweight* FlyweightFactory::GetFlyweight(string key) {
      >        vector<Flyweight*>::iterator iter = this->m_vecFly.begin();
      >        for (; iter!=this->m_vecFly.end(); iter++) {
      >            if ((*iter)->GetIntrinsicState() == key) {
      >                return *iter;
      >            }
      >        }
      >        Flyweight* fly = new ConcreteFlyweight(key);
      >        this->m_vecFly.push_back(fly);
      >        return fly;
      >    }
      >
      >    void FlyweightFactory::GetFlyweightCount() {
      >        cout<<this->m_vecFly.size()<<endl;
      >    }
      >    //
      >    //  main.cpp
      >    //  FlyWeight
      >    //
      >    //  Created by NL on 2017/8/25.
      >    //  Copyright © 2017年 NL. All rights reserved.
      >    //
      >
      >    #include <iostream>
      >    #include "Flyweight.hpp"
      >    int main(int argc, const char * argv[]) {
      >        //外部状态extrinsicState
      >        string extrinsicState = "ext";
      >      	//工厂模式，
      >        FlyweightFactory *fc = new FlyweightFactory();
      >      	//向工厂申请一个Flyweight对象，且对象的内部状态值为hello
      >        Flyweight *fly = fc->GetFlyweight("hello");
      >        Flyweight *fly1 = fc->GetFlyweight("hello");
      >      	//应用外部状态
      >        fly->Operation(extrinsicState);
      >        fc->GetFlyweightCount();
      >        return 0;
      >    }
      >    /*
      >    hello
      >    ext
      >    1
      >    */
      >    ```
      >

6. Facade模式-外观模式

   > 1. 问题：为了降低复杂性，常常将系统划分为若干个子系统。但是如何做到各个系统之间的通信和相互依赖关系达到最小呢？
   >
   > 2. 概述：我们通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象，这样无疑会降低应用程序的复杂度，并且提高了程序的可维护性。
   >    例子1：一个电源总开关可以控制四盏灯、一个风扇、一台空调和一台电视机的启动和关闭。该电源总开关可以同时控制上述所有电器设备，电源总开关即为该系统的外观模式设计。
   >
   > 3. 为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。
   >
   >    ```c++
   >    //
   >    //  Facade.hpp
   >    //  Facade
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Facade_hpp
   >    #define Facade_hpp
   >
   >    #include <stdio.h>
   >    class Subsystem1 {
   >    public:
   >        Subsystem1();
   >        ~Subsystem1();
   >        void Oparation();
   >    };
   >    class Subsystem2 {
   >    public:
   >        Subsystem2();
   >        ~Subsystem2();
   >        void Oparation();
   >    };
   >
   >    class Facade {
   >    public:
   >        Facade();
   >        ~Facade();
   >        void OperationWrapper();
   >    private:
   >        Subsystem1* subs1;
   >        Subsystem2* subs2;
   >    };
   >    #endif /* Facade_hpp */
   >    //
   >    //  Facade.cpp
   >    //  Facade
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Facade.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    Subsystem1::Subsystem1(){}
   >    Subsystem1::~Subsystem1(){}
   >    void Subsystem1::Oparation() {
   >        cout<<"Sub1 operation"<<endl;
   >    }
   >
   >    Subsystem2::Subsystem2(){}
   >    Subsystem2::~Subsystem2(){}
   >    void Subsystem2::Oparation() {
   >        cout<<"Sub2 operation"<<endl;
   >    }
   >
   >    Facade::Facade(){
   >        this->subs1 = new Subsystem1();
   >        this->subs2 = new Subsystem2();
   >    }
   >
   >    Facade::~Facade(){
   >        delete subs1;
   >        delete subs2;
   >    }
   >
   >    void Facade::OperationWrapper() {
   >        this->subs1->Oparation();
   >        this->subs2->Oparation();
   >    }
   >    //
   >    //  main.cpp
   >    //  Facade
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Facade.hpp"
   >    using namespace std;
   >    int main(int argc, const char * argv[]) {
   >        Facade *f = new Facade();
   >        f->OperationWrapper();
   >        return 0;
   >    }
   >
   >    /*
   >    Sub1 operation
   >    Sub2 operation
   >    */
   >    ```
   >
   > 4. 讨论：Facade模式在高层提供了一个统一的接口，解耦了系统，设计模式还有另一种模式Mediator也和Facade模式有类似得地方。但是Mediator主要目的是对相见的访问的解耦。

7. Proxy模式-代理模式

   > 1. 作用：为其他对象提供一种代理以控制对这个对象的访问。
   >
   > 2. 代理的种类
   >
   >    1. **远程（Remote）代理**：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。 也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
   >    2. **虚拟（Virtual）代理**：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。
   >    3. **保护（Protect or Access）代理**：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。 用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。
   >    4. **智能引用（Smart Reference）代理**：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。 是指当调用真实的对象时，代理处理另外一些事。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。
   >
   > 3. ```c++
   >    //
   >    //  Proxy.hpp
   >    //  Proxy
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #ifndef Proxy_hpp
   >    #define Proxy_hpp
   >
   >    #include <stdio.h>
   >    // 定义了Proxy和ConcreteSubject的公有接口
   >    // 这样就可以在任何需要使用到ConcreteSubject的地方都使用Proxy
   >    class Subject {
   >    public:
   >        virtual ~Subject();
   >        virtual void Request() = 0;
   >    protected:
   >        Subject();
   >    };
   >
   >    class ConcreteSubject: public Subject{
   >    public:
   >        ConcreteSubject();
   >        ~ConcreteSubject();
   >        virtual void Request();
   >    };
   >
   >    class Proxy: public Subject {
   >    public:
   >        Proxy();
   >        ~Proxy();
   >        void DoSomething1();
   >        void DoSomething2();
   >        virtual void Request();
   >    private:
   >        Subject* _subject;
   >    };
   >    #endif /* Proxy_hpp */
   >    //
   >    //  Proxy.cpp
   >    //  Proxy
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include "Proxy.hpp"
   >    #include <iostream>
   >    using namespace std;
   >    Subject::Subject(){}
   >    Subject::~Subject(){}
   >    ConcreteSubject::ConcreteSubject(){}
   >    ConcreteSubject::~ConcreteSubject(){}
   >    void ConcreteSubject::Request() {
   >        cout<<"ConcreteSubject::Request"<<endl;
   >    }
   >
   >    Proxy::Proxy():_subject(NULL) {
   >    }
   >    Proxy::~Proxy(){
   >        delete _subject;
   >    }
   >    void Proxy::DoSomething1(){
   >        cout<<"Proxy::Dosomething1"<<endl;
   >    }
   >    void Proxy::DoSomething2(){
   >        cout<<"Proxy::Dosomething2"<<endl;
   >    }
   >    void Proxy::Request() {
   >        if (NULL == this->_subject)
   >            this->_subject = new ConcreteSubject();
   >        this->DoSomething1();  //表示额外附加的操作
   >        this->_subject->Request();  //代理的实体类的操作
   >        this->DoSomething2();
   >    }
   >    //
   >    //  main.cpp
   >    //  Proxy
   >    //
   >    //  Created by NL on 2017/8/26.
   >    //  Copyright © 2017年 NL. All rights reserved.
   >    //
   >
   >    #include <iostream>
   >    #include "Proxy.hpp"
   >    int main(int argc, const char * argv[]) {
   >        Proxy* p = new Proxy();
   >        p->Request();
   >        return 0;
   >    }
   >    ```
   >
   > 4. 讨论：Proxy模式最大的好处就是实现了逻辑和实现的彻底解耦

