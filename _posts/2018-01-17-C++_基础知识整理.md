---
layout:   post
title:    "C++ 基础知识整理"
subtitle: "在路上，，，"
date:     2018-01-17
author:   "NL"
header-img: "img/post-bg-2015.jpg"
tags:
    - C++
---

1. new、delete、malloc、free关系

   相同处：他们都可以申请动态内存和释放内存

   不同处：

   ​	类型：new、delete是运算符，malloc、free是标准库函数

   ​	对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。由此需要new、delete运算符来完成对象的构造和销毁

   ​


2. new、delete

   new 简单数据类型

   1. 简单类型直接调用operator new分配内存；
   2. 可以通过new_handler来处理new失败的情况；
   3. **new分配失败的时候不像malloc那样返回NULL，它直接抛出异常。要判断是否分配成功应该用异常捕获的机制；**

   复杂数据类型

   1. **复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数。**

   delete 简单数据类型

   1. 只是调用free函数

   复杂数据类型

   1. **delete复杂数据类型先调用析构函数再调用operator delete。**

   new[] 简单数据类型

   **可以通过()初始化数组为零值，实例 :char\* p = new char\[32\]();   **

   1. **new[]计算好大小后调用operator new。**

   复杂数据类型

   1. **针对复杂类型，new[]会额外存储数组大小。**

   delete[] 与new[] 相反

   ​

3. C++的性质

   1. 封装、继承、多态
   2. 封装：封装可以隐藏实现细节，使得代码模块化
      1. 数据抽象是一个把实现细节与相关的数据分离开的概念。


   3. 继承

      > - 公有继承
      >   当类的继承方式为公有继承时，基类的公有和保护成员的访问属性在派生类中不变，而基类的私有成员不可访问。即**基类的公有成员和保护成员被继承到派生类中仍作为派生类的公有成员和保护成员**。派生类的其他成员可以直接访问它们。无论派生类的成员还是派生类的对象都无法访问基类的私有成员。
      > - 私有继承
      >   当类的继承方式为私有继承时，**基类中的公有成员和保护成员都以私有成员身份出现在派生类中**，而基类的私有成员在派生类中不可访问。基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的其他成员可以直接访问它们，但是在类外部通过派生类的对象无法访问。无论是派生类的成员还是通过派生类的对象，都无法访问从基类继承的私有成员。通过多次私有继承后，对于基类的成员都会成为不可访问。因此私有继承比较少用。
      > - 保护继承
      >   保护继承中，**基类的公有成员和私有成员都以保护成员的身份出现在派生类中**，而基类的私有成员不可访问。派生类的其他成员可以直接访问从基类继承来的公有和保护成员，但是类外部通过派生类的对象无法访问它们，无论派生类的成员还是派生类的对象，都无法访问基类的私有成员。


      4. 多态：多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说：允许将子类类型的指针赋值给父类类型的指针（一个接口，多种方法）。
      1. C++ 支持两种多态性：编译时多态性，运行时多态性。
      2. 编译时多态性（静态多态）：通过重载函数实现。
      3. 运行时多态性（动态多态）：通过虚函数实现（覆盖）


   5. 抽象类

      1. 抽象类中可以有多个纯虚函数
      2. 不能声明抽象类的对象，但可以声明指向抽象类的指针变量和引用变量
      3. 抽象类也可以定义其他非纯虚函数
      4. 如果派生类中没有重新定义基类中的纯虚函数，则在派生类中必须再将该虚函数声明为纯虚函数
      5. 从抽象类可以派生出具体或抽象类，但不能从具体类派生出抽象类
      6. 在一个复杂的类继承结构中，越上层的类抽象程度越高，有时甚至无法给出某些成员函数的实现，显然，抽象类是一种特殊的类，它一般处于类继承结构的较外层
      7. 引入抽象类的目的，主要是为了能将相关类组织在一个类继承结构中，并通过抽象类来为这些相关类提供统一的操作接口

   6. 虚函数表[link](https://my.oschina.net/hnuweiwei/blog/280894)：

      > 虚函数表只有一个，只是对于类来说的，类的对象都会有虚指针，指向虚函数表
      >
      > **一般继承（无虚函数覆盖）**：（对于子类对象）
      >
      > a. 虚函数按照其声明顺序放于表中。
      >
      > b. 父类的虚函数放在子类的虚函数前面
      >
      > **一般覆盖（有虚函数覆盖）**：对于子类
      >
      > a. 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
      >
      > b. 没有被覆盖的依旧。
      >
      > **多重继承（无虚函数覆盖）**：子类对象
      >
      > a. 每个父类都有自己的虚函数表。
      >
      > b. 子类成员函数被放在第一个父类的表中。
      >
      > **多重继承（有虚函数覆盖）**：子类对象
      >
      > a. 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
      >
      > b. 没有被覆盖的依旧
      >
      > ​
      >
      > 虚析构函数：主要防止内存泄漏，先析构子类，后析构父类
      >
      > 虚构造函数：C++不支持，构建一个对象时，必须知道具体的类型信息。		

   ​

4. 引用作为函数返回值的类型

   > 1. 好处
   >    1. 在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error! 
   > 2. 注意事项
   >    1. 不能返回局部变量的引用
   >    2. 不能返回函数内部new分配的内存的引用
   >    3. 可以返回类成员的引用，但最好是const
   >    4. 流操作符重载返回值申明为“引用”的作用：只能有一个流对象。



5. 结构体与联合有何区别

   > 1. 结构体和联合都是以多个不同的数据类型成员组成的，但在任何时候联合中只存放了一个被选中的成员（所有成员共用一块地址），而结构体的所有成员都有内存地址
   > 2. 对于联合成员赋值会覆盖其他数据成员，结构体互不影响。

   ​

6. 重写（override）与重载（overload）

   > 1. 定义
   >    1. 重载：允许存在多个同名的函数，而这些函数的参数个数、类型不相同。
   >    2. 重写：子类重新定义父类虚函数的方法
   > 2. 实现原理
   >    1. 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的），它们的地址在编译期就绑定了
   >    2. 重写：当子类重新定义了父类的虚函数之后，父类指针根据赋给他的不同子类指针，动态的调用属于子类的该函数，这样的函数调用载编译期是无法确定的（调用的子类函数地址无法给出）。因此，这样的函数地址是在运行期绑定的。



7. 杂记

   > 当类中含有const、reference成员变量；基类的构造函数都需要初始化表。
   >
   > ​
   >
   > C++不是类型安全的，两个不同类型的指针之间可以强制转换。
   >
   > ​
   >
   > Main函数执行之前，全局对象的构造函数会在main 函数之前执行。

   ​

8. 内存分配方式以及区别[url](https://www.cnblogs.com/talenth/archive/2013/04/17/5807947.html)

   > 1. 静态存储区域分配，内存在程序编译额时候就已经分配好了，这块内存在程序运行期间一直存在。例如全局变量，static变量。
   > 2. 在栈上分配，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行完毕时内存全部释放
   > 3. 在堆上分配，亦称动态内存分配，程序在运行时用malloc或new申请任意大小的内存，动态内存的生存期由程序员控制
   > 4. 堆栈的区别：
   >    1. 管理方式：堆：有程序员或者os管理，栈有编译器管理。
   >    2. 碎片：堆产生的比较多，栈不会存在这种问题。
   >    3. 生长方向：堆向高地址，栈向低地址。
   >    4. 分配方式：堆都是动态分配的，没有静态分配堆；栈分为静态分配、动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现
   >    5. 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多


9. const与define的区别

   > 1. 编译器处理方式不同
   >
   >    define宏在预处理阶段展开；const常量时编译运行阶段使用。
   >
   > 2. 类型和安全检查不同
   >
   >    define没有类型，不做任何类型检查，仅仅是展开；const常量有具体的类型，在编译阶段会执行类型检查。
   >
   > 3. 存储方式不同
   >
   >    define仅仅是展开，不会分配内存（变量定义分配内存）；const常量会在内存中分配。
   >
   > 4. const可以节省内存，避免不必要的内存分配。

10. 数组与指针的区别

  > 1. 下标：
  >    1. 数组可以直接对数据进行访问，如果我们定义一个数组int A[ 10 ], A的地址和A[ 0 ]的地址是相同的。
  >    2. 指针对数据的访问实际上是间接访问，int * p, p的地址和p[ 0 ]的地址绝对是不同的。
  > 2. 当数组声明被用作函数形参的时候，该数组实际会被当作指针来使用。
  > 3. 当用下标操作符对数组和指针进行运算的时候，数组和指针是等价的。a[ i ]会被编译器翻译成*(a+i)的形式。
  > 4. 对于定义和声明，数组和指针是不相同的，定义为数组，则声明也应该是数组，如果混合使用会出现意料不到的错误。

11. 数组指针与指针数组[url](http://blog.csdn.net/sum_TW/article/details/53540866)

    > 1. 数组指针：指向数组的指针
    >    1. Int (\*p)[4];
    > 2. 指针数组：存放指针的数组
    >    1. int \*p[4];
    > 3. 总结：数组名的类型是指向元素类型的指针，值是指针常量。(a+1)的类型是一个指针变量。把数组名作为参数传递的时候实际上传递的是一个指针变量。sizeof对变量和数组名操作时返回的结果会不一样。数组指针是指向数组的指针，其值可以是变量。
    > 4. 函数指针：int  (\*fun)(int)
    > 5. 指针函数：int \*fun(int)

12. 引用与指针

    > 1. 引用必须初始化，指针不必。
    > 2. 引用不可以指向空值，但是指针可以。
    > 3. 引用初始化后不可改变，但是指针更改指向。

13. **memset、memcpy和strcpy的区别**

    > 1. memcpy是内存拷贝函数，可以拷贝任何数据类型的对象，memcpy(b, a, sizeof(b));
    > 2. Strcpy只能拷贝字符串，遇到“\0”结束
    > 3. memset用来对一段内存进行设置为某个字符。

14. struct和class的区别

    > 1. 在默认情况下，struct的成员变量是public的，而class是private的
    > 2. struct保证成员按照声明顺序在内存存储，而class不能保证
    > 3. 对于继承来说，struct是public继承，class默认是private继承

15. **如何引用一个已经定义过的全局变量？区别是什么**

    > 如果在同一个文件中，直接引用即可。
    >
    > 如果不在同一个文件，有两种方式：
    >
    > 1. 直接引用头文件就可以使用了。
    > 2. 用extern关键字重新声明一下。

16. static关键字

    > 1. 为什么引入static：编译器为局部变量在栈上分配内存，但是函数执行完内存就会释放掉。所以static可以解决这种问题，因为他存储在静态变量区。
    > 2. 缺点：不安全，作用域是全局的
    > 3. 优点：因为静态变量对所有对象所公有的，可以节省内存，提高时间效率。
    > 4. 作用
    >    1. 可以用于全局变量的定义：为该变量分配静态存储区。程序运行结束前不会被释放。
    >    2. 声明和定义静态函数：表示该函数是静态函数，只能在本文件中使用
    >    3. 定义静态成员变量：只初始化一次，只有程序运行完才能释放。
    > 5. **基类和派生类共享该基类的静态成员变量内存**。
    > 6. static成员变量：
    >    1. static数据成员独立于该类的任意对象而存在；static数据成员（const static数据成员除外）在类定义体内声明，必须在类外进行初始化。不像普通数据成员，static成员不能在类的定义体中初始化，只能在定义时才初始化。 static数据成员定义放在cpp文件中，不能放在初始化列表中。Const static成员可就地初始化。
    > 7. static全局变量：只在一个文件中有效。
    > 8. 静态成员能用于某些场景，而普通成员不行
    >    1. 静态成员可以是不完全类型
    >    2. 静态成员可以成为默认参数
    >    3. **不完全类型只能以有限方式使用。不能定义该类型的对象。不完全类型只能用于定义指向该类型的指针及引用，或者用于声明使用该类型作为形参类型或者返回值类型。**

17. **类和对象的两个基本概念**

    > 类的作用或概念：用来描述一组具有相似属性的东西的对象的一种数据结构。类中有数据成员的声明和定义，有成员函数的实现代码。对象就是类的实例化。计算机中想要使用类，只能进行实例化。

18. 函数模版和类模版有什么区别

    > 1. 函数模版的实例化是由编译器在处理函数调用时自动完成的，而类模版的实例化必须由程序员在程序中显式指定

19. system("pause")是调用DOS命令，按任意键继续。系统命令，

20. 标准的strcpy函数

    ```c++
    char* Strcpy(char *strDest, const char * strSrc) {
        assert((strDest == nullptr) || (strSrc == nullptr));
        char *address = strDest;
        while( (*strDest++ = * strSrc++) != ‘\0’);
        return address;
    }
    ```

21. 常量指针和指针常量的区别

    > 1. 常量指针：是一个指向常量的指针，可以防止对指针误操作而修改常量的值
    > 2. 指针常量：是一个指针，且一个常量，指针常量不能修改指针指向的地址，一旦初始化，但是指向的值可以改变

22. 空指针：表示“未分配”或者“尚未指向任何地方”的指针

23. C++文件编译与执行阶段

    > 1. 预处理阶段，根据文件中预处理指令来修改源文件： 1、宏定义　 2、文件包含　 3、条件编译
    > 2. 编译阶段：将其翻译成中间代码或汇编代码
    > 3. 汇编阶段：把汇编语言翻译成目标机器指令
    > 4. 链接：例如：某个源文件中的函数可能引用了另一个源文件中定义的某个函数；在程序中可能调用了某个库文件中的函数

24. **#error 预处理**

    error 预处理指令的作用是，编译程序时，只要遇到#error 就会生成一个编译错误提示消息，并停止编译。

25. 内联函数与宏

    > 1. 内联函数载编译时展开，宏是预处理时替换
    > 2. 在编译时内联函数可以直接替换到代码中，而宏只是简单的文本替换
    > 3. 内联函数可以完成诸如类型检测、语句是否正确等编译功能，宏就不具备这样的功能
    > 4. 内联函数式函数，宏不是

26. iostream.h和iostream

    > 1. iostream.h时非标准输入输出流
    > 2. iostream是标准输入输出流

27. 带有参数的宏与函数的优缺点

    > 1. 宏
    >    1. 优点：在预处理阶段，不占用编译时间，同时省去了函数调用的开销。
    >    2. 缺点：不进行类型安全检查，多次宏替换会导致体积变大。
    > 2. 函数
    >    1. 优点：有类型检查，比较安全
    >    2. 缺点：函数调用需要参数、返回值地址的入栈、出栈开销，效率不太高

28. 多态的作用

    > 1. 实现函数接口重用
    > 2. 可以隐藏实现的细节，使得代码模块化；方便拓展代码

29. 指针与引用区别

    > 1. 引用在创建的时候必须初始化，保证引用对象是有效的。所以不存在NULL引用；而指针在定义时不必初始化，所以可以是NULL，可以在之后重新复制
    > 2. 引用一旦被初始化为指向一个对象，他就不能为另一个对象引用；而指针，可以多次更改
    > 3. 引用的创建与销毁不会调用拷贝构造函数

30. 拷贝构造函数相关问题

    > 1. 深拷贝：拷贝了指针和资源
    > 2. 浅拷贝：拷贝了指针，没有资源，所以可能带来两个指针指向同一个地址，析构两次
    > 3. 临时对象的开销比局部对象小些。

31. 智能指针

    > 当类中含有指针成员，一般有两种方式管理指针
    >
    > 1. 每个类对象都保留一份指针指向的对象的拷贝
    > 2. 使用智能指针，从而实现指针指向对象的共享。实质是使用计数器与对象相关联，这样做可以保证对象的正确删除，避免垂悬指针。
    >
    > 每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数，并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数。

32. 指针

    > 1. void \*类型指针：通用变体指针，可以不经转换，赋给其他指针，函数指针除外。
    > 2. NULL指针：是一个标准规定的宏定义，#define NULL ((void\*)0)用来表示空指针常量
    > 3. 零指针：指针值为0，没有存储任何内存地址的指针。
    > 4. 空指针：指针赋值为0，零指针和NULL指针都是空指针
    > 5. 野指针：指向垃圾内存的指针；1、指针变量没有初始化；2、指针被delete或者free之后，没有赋空；3、指针操作超越了变量的范围
    > 6. 垂悬指针：指向曾经存放对象的内存，但是该对象不存在了；delete操作完成后的指针就是悬垂指针，此时需要将指针置为0变为零值指针；

33. 需要构造函数初始化列表的成员

    > const成员、引用成员

34. 阻止一个类实例化：定义为抽象类或者构造函数为private

35. 不允许类外部创建类对象，只能在类内部创建：就构造函数为private

36. 变量的定义与声明

    > 1. 声明：
    >    1. 一种是需要建立存储空间的，定义性声明：所谓的定义
    >    2. 另一种是不需要建立存储空间的，只是告诉编译器某变量已经在别处定义了。

37. 回调函数

    > 1. 概念：就是使用者定义一个函数，并实现，然后把这个函数作为参数传入另一个函数中，由别人的函数在运行时调用这个函数
    >
    >    ```c++
    >    void PrintText() {
    >      printf("hello world");
    >    }
    >
    >    void CallPrintText(void (*callfunc)()) {
    >      callfunc();
    >    }
    >
    >    int main() {
    >      CallPrintText(PrintText);
    >      return 0;
    >    }
    >
    >    //修改为带参的调用。
    >    void PrintText(char *s) {
    >      printf("%s\n", s);
    >    }
    >
    >    void CallPrintText(void (*callfunc)(char *), char *s) {
    >      callfunc(s);
    >    }
    >
    >    int main() {
    >      CallPrintText(PrintText, "hello world");
    >      return 0;
    >    }
    >    ```

38. explicit关键字

    > 1. 在C++中，如果构造函数只有一个参数时，那么在编译的时候就会有一个缺省的转换操作；将该构造函数对应的数据类型转换为该类对象。例如：A a = 10;
    > 2. explicit只能修饰一个参数的构造函数，他的作用时是表明该构造函数是显示的，而非隐式的。构造函数加了explicit之后，就关闭了隐式转换，上面的例子就是error的

39. 智能指针,[uri](https://www.cnblogs.com/lanxuezaipiao/p/4132096.html)

    > 1. 设计思想：将基本类型指针封装为类对象指针，并在析构函数中delete指针指向的内存
    >
    > 2. auto_ptr：可能会在运行时出现内存崩溃的问题
    >
    > 3. unique_ptr：比auto_ptr安全一点，在编译器就会抛出所有权转换的错误，如果只是临时unique_ptr，编译器是允许这么做的。但是也存在将unique_ptr赋给另一个unique_ptr，可以通过std::move()函数
    >
    > 4. 智能指针都有一个explicit构造函数
    >
    > 5. share_ptr：基于引用计数的指针，可随意赋值，知道内存中的引用计数为0这个内存才会被释放
    >
    > 6. weak_ptr：弱引用，引用计数有一个问题就是互相引用形成环，weak_ptr它是只引用不计数。所以不会存在成环问题
    >
    >    ```c++
    >    //引用成环
    >    #include <iostream>
    >    #include <memory.h>
    >    #include <string>
    >    using namespace std;
    >    class B;
    >    class A {
    >    public:
    >        shared_ptr<B>m_b;
    >    };
    >
    >    class B {
    >    public:
    >        shared_ptr<A>m_a;
    >    };
    >     int main() {
    >      shared_ptr<A>a(new A);
    >       shared_ptr<B>b(new B);
    >       a->m_b = b;
    >       b->m_a = a;
    >       cout<<a.use_count()<<endl;
    >       cout<<b.use_count()<<endl;
    >       return 0;
    >     }
    >
    >     //weak_ptr使用
    >
    >    #include <iostream>
    >    #include <memory.h>
    >    #include <string>
    >    using namespace std;
    >       class node;
    >       typedef weak_ptr<node> ptr_type;
    >    class node {
    >       public:
    >            ptr_type next;
    >       node(){
    >           cout<<"node"<<endl;
    >       }
    >       ~node(){
    >           cout<<"destory"<<endl;
    >       }
    >    };
    >    int main() {
    >      auto p1 = make_shared<node>();
    >       auto p2 = make_shared<node>();
    >       p1->next = p2;
    >       p2->next = p1;
    >    }
    >    ```
    >
    > 7. 实现智能指针
    >
    >
    >    ```c++
    > #include <iostream>
    > #include <memory.h>
    > #include <string>
    > using namespace std;
    > template <typename T>
    > class SmartPointer {
    > private:
    >     T *_ptr;
    >     size_t *reference_count;
    >     void releaseCount() {
    >         if (_ptr) {
    >             (*reference_count)--;
    >             if ((*reference_count) == 0) {
    >                 delete _ptr;
    >                 delete reference_count;
    >             }
    >         }
    >     }
    > public:
    >     //构造函数
    >     SmartPointer(T *p=0):_ptr(p),reference_count(new size_t) {
    >         if (p)
    >             *reference_count = 1;
    >         else
    >             *reference_count = 0;
    >     }
    >     //拷贝构造函数
    >     SmartPointer(const SmartPointer &src) {
    >         if (this != &src) {
    >             _ptr = src._ptr;
    >             reference_count = src.reference_count;
    >             (*reference_count)++;
    >         }
    >     }
    >     //重载赋值操作符
    >     SmartPointer& operator = (const SmartPointer &src) {
    >         if (_ptr == src._ptr)
    >             return *this;
    >         releaseCount();
    >         _ptr = src._ptr;
    >         reference_count = src.reference_count;
    >         (*reference_count)++;
    >         return *this;
    >     }
    >     //重载操作符
    >     T& operator*() {
    >         if (_ptr)
    >             return *_ptr;
    >     }
    >     T* operator->() {
    >         if (_ptr)
    >             return _ptr;
    >     }
    >     ~SmartPointer() {
    >         if (--(*reference_count) == 0) {
    >             delete _ptr;
    >             delete reference_count;
    >         }
    >     }
    >     size_t use_count() {
    >         return *reference_count;
    >     }
    > };
    > int main() {
    >     SmartPointer<char>cp1(new char('a'));
    >     cout<<cp1.use_count()<<endl;
    >     SmartPointer<char>cp2(cp1);
    >     cout<<cp2.use_count()<<endl;
    >     SmartPointer<char>cp3;
    >     cp3 = cp2;
    >     cout<<cp3.use_count()<<endl;
    >     return 0;
    > }
    >    ```

40. inline函数：必须放在函数定义时，才算内联函数，放在声明前是不起作用的。

    > 1. 内联函数以代码膨胀为代价，仅仅省去了函数调用的开销，从而提高效率
    > 2. 慎用inline
    >    1. 代码很长，将导致内存消耗代价较高。
    >    2. 函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大

41. const和constexpr变量

    > 1. const和constexpr之间的主要区别在于，const变量的初始化，可以延迟到运行期，而constexpr变量必须在编译时。进行初始化。
    > 2. constexpr函数会在编译时计算其返回值。
    > 3. constexpr只对指针有效
    > 4. **如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针本身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。**

42. 何谓面向对象思想

    >把一组数据结构和处理它们的方法组成对象，把相同行为的对象归纳为类，通过类的封装隐藏内部细节，通过继承实现类的特化/泛化，通过类的多态实现基于对象类型的动态分派。
    >
    >**定义在类内部的函数是隐式的inline函数。**

43. Lambda函数

    > 1. 优点
    >    1. 声明式编程风格，就地匿名定义函数，不需要额外写一个命名函数或者对象。好的可读性和可维护性
    >    2. 简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散
    >    3. 实现功能闭包。
    > 2. 捕获列表
    >    1. []不捕获任何变量。
    >    2. [&]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。
    >    3. [=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。
    >    4. [=,&foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。
    >    5. [bar]按值捕获bar变量，同时不捕获其他变量。
    >    6. [this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。
    > 3. 细节
    >    1. 延迟调用，lambda表达式按值捕获了所有外部变量时，在捕获的一瞬间，a的值就已经被复制了。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。
    >    2. 修改按值捕获的外部变量，需要显示指明lambda表达式为mutable。
    >    3. 没有捕获变量的lambda表达式，可以转换为

44. 乐观锁和悲观锁

    > 1. 悲观锁：
    >    1. 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。
    >    2. 流程：在对任意记录进行修改前，先尝试为该记录加上[排他锁](http://www.hollischuang.com/archives/923)（exclusive locking）；如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定；如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了；其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。
    >    3. 优点与不足：悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数
    > 2. 乐观锁：
    >    1. 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。
    >    2. 流程：数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。
    >    3. 优点与不足：乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。


