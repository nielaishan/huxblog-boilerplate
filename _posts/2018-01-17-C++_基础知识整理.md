---
layout:   post
title:    "C++ 基础知识整理"
subtitle: "在路上，，，"
date:     2018-01-17
author:   "NL"
header-img: "img/post-bg-2015.jpg"
tags:
    - C++
---

1. new、delete、malloc、free关系

   相同处：他们都可以申请动态内存和释放内存

   不同处：

   ​	类型：new、delete是运算符，malloc、free是标准库函数

   ​	对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。由此需要new、delete运算符来完成对象的构造和销毁

   ​


2. new、delete

   new 简单数据类型

   1. 简单类型直接调用operator new分配内存；
   2. 可以通过new_handler来处理new失败的情况；
   3. **new分配失败的时候不像malloc那样返回NULL，它直接抛出异常。要判断是否分配成功应该用异常捕获的机制；**

   复杂数据类型

   1. **复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数。**

   delete 简单数据类型

   1. 只是调用free函数

   复杂数据类型

   1. **delete复杂数据类型先调用析构函数再调用operator delete。**

   new[] 简单数据类型

   **可以通过()初始化数组为零值，实例 :char\* p = new char\[32\]();   **

   1. **new[]计算好大小后调用operator new。**

   复杂数据类型

   1. **针对复杂类型，new[]会额外存储数组大小。**

   delete[] 与new[] 相反

   ​

3. C++的性质

   1. 封装、继承、多态
   2. 封装：封装可以隐藏实现细节，使得代码模块化
      1. 数据抽象是一个把实现细节与相关的数据分离开的概念。


   3. 继承

      > - 公有继承
      >   当类的继承方式为公有继承时，基类的公有和保护成员的访问属性在派生类中不变，而基类的私有成员不可访问。即**基类的公有成员和保护成员被继承到派生类中仍作为派生类的公有成员和保护成员**。派生类的其他成员可以直接访问它们。无论派生类的成员还是派生类的对象都无法访问基类的私有成员。
      > - 私有继承
      >   当类的继承方式为私有继承时，**基类中的公有成员和保护成员都以私有成员身份出现在派生类中**，而基类的私有成员在派生类中不可访问。基类的公有成员和保护成员被继承后作为派生类的私有成员，派生类的其他成员可以直接访问它们，但是在类外部通过派生类的对象无法访问。无论是派生类的成员还是通过派生类的对象，都无法访问从基类继承的私有成员。通过多次私有继承后，对于基类的成员都会成为不可访问。因此私有继承比较少用。
      > - 保护继承
      >   保护继承中，**基类的公有成员和私有成员都以保护成员的身份出现在派生类中**，而基类的私有成员不可访问。派生类的其他成员可以直接访问从基类继承来的公有和保护成员，但是类外部通过派生类的对象无法访问它们，无论派生类的成员还是派生类的对象，都无法访问基类的私有成员。


   4. 多态：多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说：允许将子类类型的指针赋值给父类类型的指针（一个接口，多种方法）。
      1. C++ 支持两种多态性：编译时多态性，运行时多态性。
      2. 编译时多态性（静态多态）：通过重载函数实现。
      3. 运行时多态性（动态多态）：通过虚函数实现（覆盖）


   5. 抽象类

      1. 抽象类中可以有多个纯虚函数
      2. 不能声明抽象类的对象，但可以声明指向抽象类的指针变量和引用变量
      3. 抽象类也可以定义其他非纯虚函数
      4. 如果派生类中没有重新定义基类中的纯虚函数，则在派生类中必须再将该虚函数声明为纯虚函数
      5. 从抽象类可以派生出具体或抽象类，但不能从具体类派生出抽象类
      6. 在一个复杂的类继承结构中，越上层的类抽象程度越高，有时甚至无法给出某些成员函数的实现，显然，抽象类是一种特殊的类，它一般处于类继承结构的较外层
      7. 引入抽象类的目的，主要是为了能将相关类组织在一个类继承结构中，并通过抽象类来为这些相关类提供统一的操作接口

   6. 虚函数表[link](https://my.oschina.net/hnuweiwei/blog/280894)：

      > 虚函数表只有一个，只是对于类来说的，类的对象都会有虚指针，指向虚函数表
      >
      > **一般继承（无虚函数覆盖）**：（对于子类对象）
      >
      > a. 虚函数按照其声明顺序放于表中。
      >
      > b. 父类的虚函数放在子类的虚函数前面
      >
      > **一般覆盖（有虚函数覆盖）**：对于子类
      >
      > a. 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
      >
      > b. 没有被覆盖的依旧。
      >
      > **多重继承（无虚函数覆盖）**：子类对象
      >
      > a. 每个父类都有自己的虚函数表。
      >
      > b. 子类成员函数被放在第一个父类的表中。
      >
      > **多重继承（有虚函数覆盖）**：子类对象
      >
      > a. 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
      >
      > b. 没有被覆盖的依旧
      >
      > ​
      >
      > 虚析构函数：主要防止内存泄漏，先析构子类，后析构父类
      >
      > 虚构造函数：C++不支持，构建一个对象时，必须知道具体的类型信息。

      ​		

​		







​	