---
layout:   post
title:    "PHP Yii2框架学习"
subtitle: "yii"
date:     2018-07-07
author:   "NL"
header-img: "img/post-bg-2015.jpg"
tags:
    - PHP
    - Yii
---

## Yii安装以及基本知识

首先介绍一下，Yii2的安装，我主要是通过composer依赖管理工具安装的，还有一种安装方式为下载一个归档文件。

1. 安装Yii的命令为：

```shell
composer create-project --prefer-dist yiisoft/yii2-app-basic [projectName]
```

2. 验证是否安装成功：

在项目文件下输入以下命令：

```shell
#默认端口是8080
php yii serve
#换其他端口
php yii serve --port=8888
```

接下来，我们来看一下，yii框架的目录结构

3. 目录结构

```shell
basic/                  应用根目录
    composer.json       Composer 配置文件, 描述包信息
    config/             包含应用配置及其它配置
        console.php     控制台应用配置信息
        web.php         Web 应用配置信息
    commands/           包含控制台命令类
    controllers/        包含控制器类
    models/             包含模型类
    runtime/            包含 Yii 在运行时生成的文件，例如日志和缓存文件
    vendor/             包含已经安装的 Composer 包，包括 Yii 框架自身
    views/              包含视图文件
    web/                Web 应用根目录，包含 Web 入口文件
        assets/         包含 Yii 发布的资源文件（javascript 和 css）
        index.php       应用入口文件
    yii                 Yii 控制台命令执行脚本
```

4. 请求生命周期
   1. 用户向入口脚本web/index.php发起请求
   2. 入口请求加载应用配置并创建一个应用实例去处理请求。
   3. 应用通过请求组件解析请求的路由。
   4. 应用创建一个控制器实例去处理请求。
   5. 控制器创建一个动作实例并针对操作执行过滤器。
   6. 如果任何一个过滤器返回失败，则动作取消。
   7. 如果所有过滤器都通过，动作将被执行。
   8. 动作会加载一个数据模型，或许是来自数据库
   9. 动作渲染一个视图，把数据模型提供给他
   10. 渲染结果返回响应组件
   11. 响应组件发送渲染结果给用户浏览器。
5. 相关知识
   1. [yii\base\Model](https://www.yiichina.com/doc/api/2.0/yii-base-model) 被用于普通模型类的父类并与数据表**无关**。[yii\db\ActiveRecord](https://www.yiichina.com/doc/api/2.0/yii-db-activerecord) 通常是普通模型类的父类但与数据表有关联（译注：[yii\db\ActiveRecord](https://www.yiichina.com/doc/api/2.0/yii-db-activerecord) 类其实也是继承自 [yii\base\Model](https://www.yiichina.com/doc/api/2.0/yii-base-model)，增加了数据库处理）。
   2. 表达式 `Yii::$app` 代表应用实例，它是一个全局可访问的单例。 同时它也是一个[服务定位器](https://www.yiichina.com/doc/guide/2.0/concept-service-locator)， 能提供 `request`，`response`，`db`等等特定功能的组件。 使用 `request` 组件来访问应用实例收到的 `$_POST` 数据。

### 入口脚本

入口脚本是应用启动流程中的第一环，通常放在web目录下，名为index.php；而控制台应用的入口脚本一般在应用根的目录下命名为yii.php，该文件需要有执行权限，通常命令为./yii \<route> [arguments]\[option]来控制控制台应用。

入口脚本主要完成以下工作：

- 定义全局常量；
- 注册composer自动加载器
- 包含Yii类文件
- 加载应用配置
- 创建一个应用实例并配置
- 调用`yii\base\Application:run()`来处理请求

```php
//web应用index.php文件
<?php

defined('YII_DEBUG') or define('YII_DEBUG', true);
defined('YII_ENV') or define('YII_ENV', 'dev');

// 注册 Composer 自动加载器
require __DIR__ . '/../vendor/autoload.php';

// 包含 Yii 类文件
require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';

// 加载应用配置
$config = require __DIR__ . '/../config/web.php';

// 创建、配置、运行一个应用
(new yii\web\Application($config))->run();
```

```php
//控制台应用入口脚本文件
#!/usr/bin/env php
<?php
/**
 * Yii console bootstrap file.
 *
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 */

defined('YII_DEBUG') or define('YII_DEBUG', true);
defined('YII_ENV') or define('YII_ENV', 'dev');

// 注册 Composer 自动加载器
require __DIR__ . '/vendor/autoload.php';

// 包含 Yii 类文件
require __DIR__ . '/vendor/yiisoft/yii2/Yii.php';

// 加载应用配置
$config = require __DIR__ . '/config/console.php';

$application = new yii\console\Application($config);
$exitCode = $application->run();
exit($exitCode);
```

## MVC

### 控制器

C为控制器，是继承yii\base\Controller类的对象，负责处理请求和生成响应，具体来说，控制器从应用主体接管控制后分析请求数据并传送到模型，传送模型结果到视图，最后生成响应信息。

> 路由
>
> 终端用户通过所谓的路由找到动作，路由格式为ModuleID/ControllerID/AcionID

### 模型

M为模型，代表业务数据、规则和逻辑的对象。

场景scenarios和验证规则rules函数设置

### 视图

V为视图，是展示数据到终端用户的代码。

### 路由

#### 设置缺省路由

在config配置中，加入

```php
'defaultRoute' => 'site/index'
```

#### 设置全拦截路由

也是在配置中，加入

```php
'catchAll' => [
    'site/index'
]
//主要用在网站维护时，所有请求指向固定网页
```

#### 配置url

在component配置中，加入

```php
'urlManager' => [
    'enablePrettyUrl' => true,  //开启美化url
    'showScriptName' => false,  //是否显示脚本名称，
    'enableStrictParsing' => false, // 是否开启严格解析
    'suffix' => '.html', // 设置后缀
    'rules' => [  //此属性包含一个规则列表，用来规定如何解析和创建URL。 这是一个主要属性，你应该根据特定的应用环境配置此属性用来生成特定格式的URL
       // ...
     ],
]
```

## 请求处理

### Request请求

一个应用的请求是用yii/web/request对象来表示的，该对象提供了诸如请求参数、HTTP头、cookie等信息。

#### 请求参数

要获取请求参数，可以调用request组件的get和post方法。他们分别返回\$_GET和\$__POST的值。例如：

```php
$request = Yii::$app->request;
$get = $request->get(); 
//等价于：$_GET
$id = $request->get('id');
//等价于：$id = isset($_GET['id']) ? $GET['id'] : ''
$id = $request->get('id', 1);
//等价于：$id = isset($_GET['id']) ? $GET['id'] : 1
//post与get相同用法
//PUT、POST和PATCH等等这些提交上来的参数是在请求体中被发送的。
$param = $request->getBodyParams; //返回所有参数
```

#### 请求方法

可以通过`Yii::$app->request->method`表达式来获取当前请求使用的HTTP方法。而且也提供了一套布尔属性用于检测当前请求是某种类型。

```php
$request = Yii:$app->request;

if ($request->isAjax) //该请求是一个AJAX请求
if ($reqeust->isGet)
if ($reqeust->isPut)
if ($reqeust->isPost)
```

#### 请求URLs

request组件提供了许多方式来检测当前请求的URL

- [url](https://www.yiichina.com/doc/api/2.0/yii-web-request#$url-detail)：返回 `/admin/index.php/product?id=100`, 此URL不包括host info部分。
- [absoluteUrl](https://www.yiichina.com/doc/api/2.0/yii-web-request#$absoluteUrl-detail)：返回 `http://example.com/admin/index.php/product?id=100`, 包含host infode的整个URL。
- [hostInfo](https://www.yiichina.com/doc/api/2.0/yii-web-request#$hostInfo-detail)：返回 `http://example.com`, 只有host info部分。
- [pathInfo](https://www.yiichina.com/doc/api/2.0/yii-web-request#$pathInfo-detail)：返回 `/product`， 这个是入口脚本之后，问号之前（查询字符串）的部分。
- [queryString](https://www.yiichina.com/doc/api/2.0/yii-web-request#$queryString-detail)：返回 `id=100`,问号之后的部分。
- [baseUrl](https://www.yiichina.com/doc/api/2.0/yii-web-request#$baseUrl-detail)：返回 `/admin`, host info之后， 入口脚本之前的部分。
- [scriptUrl](https://www.yiichina.com/doc/api/2.0/yii-web-request#$scriptUrl-detail)：返回 `/admin/index.php`, 没有path info和查询字符串部分。
- [serverName](https://www.yiichina.com/doc/api/2.0/yii-web-request#$serverName-detail)：返回 `example.com`, URL中的host name。
- [serverPort](https://www.yiichina.com/doc/api/2.0/yii-web-request#$serverPort-detail)：返回 80, 这是web服务中使用的端口。

#### HTTP头

```php
$headers= Yii::$app->request->headers;
/ 返回 Accept header 值
$accept = $headers->get('Accept');
```

请求组件也提供了支持快速访问常用头的方法，包括：

- [userAgent](https://www.yiichina.com/doc/api/2.0/yii-web-request#$userAgent-detail)：返回 `User-Agent` 头。
- [contentType](https://www.yiichina.com/doc/api/2.0/yii-web-request#$contentType-detail)：返回 `Content-Type` 头的值， `Content-Type` 是请求体中MIME类型数据。
- [acceptableContentTypes](https://www.yiichina.com/doc/api/2.0/yii-web-request#$acceptableContentTypes-detail)：返回用户可接受的内容MIME类型。 返回的类型是按照他们的质量得分来排序的。得分最高的类型将被最先返回。
- [acceptableLanguages](https://www.yiichina.com/doc/api/2.0/yii-web-request#$acceptableLanguages-detail)：返回用户可接受的语言。 返回的语言是按照他们的偏好层次来排序的。第一个参数代表最优先的语言。

#### 客户端信息

通过userHost和userIP分别获取host name和客户机的IP地址

```php
$userHost = Yii::$app->request->userHost;
$userIP = Yii::$app->request->userIP;
```

### 响应

当应用处理完一个请求后，这个请求生成一个response响应对象并把这个响应对象发送给终端用户，响应对象包含的信息HTTP状态码，HTTP头和主体内容等。

#### 状态码

构建响应要做的第一件事就是声明请求是否被成功处理，我们通过设置`yii\web\Response::$statusCode`这个属性来做到这一点，该属性接受一个有效的HTTP状态码。

如果需要指定请求失败，可抛出对应的HTTP异常

- yii\web\NotFoundHttpException：状态码404

- yii\web\BadRequestHttpException：状态码 400。
- [yii\web\ConflictHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-conflicthttpexception)：状态码 409。
- [yii\web\ForbiddenHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-forbiddenhttpexception)：状态码 403。
- [yii\web\GoneHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-gonehttpexception)：状态码 410。
- [yii\web\MethodNotAllowedHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-methodnotallowedhttpexception)：状态码 405。
- [yii\web\NotAcceptableHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-notacceptablehttpexception)：状态码 406。
- [yii\web\NotFoundHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-notfoundhttpexception)：状态码 404。
- [yii\web\ServerErrorHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-servererrorhttpexception)：状态码 500。
- [yii\web\TooManyRequestsHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-toomanyrequestshttpexception)：状态码 429。
- [yii\web\UnauthorizedHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-unauthorizedhttpexception)：状态码 401。
- [yii\web\UnsupportedMediaTypeHttpException](https://www.yiichina.com/doc/api/2.0/yii-web-unsupportedmediatypehttpexception)：状态码 415。

如果想抛出的异常不在以上列表，可创建一个`yii\web\HttpException`异常，例如`throw new \yii\web\HttpException`

#### HTTP头部

可在reponse组件中操控header来发送HTTP头部信息，例如

```php
$headers = Yii::$app->response->headers;
//增加一个Pragma头，已存在的Pragma头不会被覆盖
$headers->add('Pragma', 'no-cache');
//设置一个Pragma头，任何已存在的Pragma头都会被丢弃
$headers->set('Pragma', 'no-cache');
//删除Pragma头并返回删除的Pragma头的只到数组
$values = $headers->remove('Pragma');
```

#### 响应主体

响应应有一个主体存放你想要显示给终端用户的内容。

如果已有格式化好的主体字符串，可赋值到响应的`yii\web\Response::$content`属性，例如：`Yii::$app->response->content='hello world'`

如果在发送给客户端用户之前需要格式化，应设置format和data属性，format属性指定data中数据格式化后的样式，例如

```php
$reponse = Yii::$app->response;
$response->format = \yii\web\Response::FORMAT_JSON;
$response->data = ['message' => 'hello world'];
```

Yii支持以下可直接使用的格式，每个实现了[formatter](https://www.yiichina.com/doc/api/2.0/yii-web-responseformatterinterface) 类， 可自定义这些格式器或通过配置[yii\web\Response::$formatters](https://www.yiichina.com/doc/api/2.0/yii-web-response#$formatters-detail) 属性来增加格式器。

- [HTML](https://www.yiichina.com/doc/api/2.0/yii-web-response#FORMAT_HTML-detail): 通过 [yii\web\HtmlResponseFormatter](https://www.yiichina.com/doc/api/2.0/yii-web-htmlresponseformatter) 来实现.
- [XML](https://www.yiichina.com/doc/api/2.0/yii-web-response#FORMAT_XML-detail): 通过 [yii\web\XmlResponseFormatter](https://www.yiichina.com/doc/api/2.0/yii-web-xmlresponseformatter)来实现.
- [JSON](https://www.yiichina.com/doc/api/2.0/yii-web-response#FORMAT_JSON-detail): 通过 [yii\web\JsonResponseFormatter](https://www.yiichina.com/doc/api/2.0/yii-web-jsonresponseformatter)来实现.
- [JSONP](https://www.yiichina.com/doc/api/2.0/yii-web-response#FORMAT_JSONP-detail): 通过 [yii\web\JsonResponseFormatter](https://www.yiichina.com/doc/api/2.0/yii-web-jsonresponseformatter)来实现.
- [RAW](https://www.yiichina.com/doc/api/2.0/yii-web-response#FORMAT_RAW-detail): use this format if you want to send the response directly without applying any formatting.

上述响应主体可明确地被设置，但是在大多数情况下是通过 [操作](https://www.yiichina.com/doc/guide/2.0/structure-controllers) 方法的返回值隐式地设置，常用场景如下所示：

```php
public function actionIndex()
{
    return $this->render('index');
}
```

上述的 `index` 操作返回 `index` 视图渲染结果， 返回值会被 `response` 组件格式化后发送给终端用户。也可以自己创建响应对象并发送给终端用户。

#### 浏览器跳转

浏览器跳转依赖于发送一个LocationHTTP头，因为该功能通常被使用，Yii提供对他提供了特别的支持。

可调用`yii\web\Response::redirect`方法将用户浏览器跳转到一个URL地址，该方法合适的带指定URL的Location头并返回他自己为响应对象，在操作的方法中，可调用缩写版`yii\web\Controller::redirect()`

除了动作方法外，可直接调用yii\web\Response::redirect()在调用yii\web\Response::send()方法来确保没有其他内容追加到响应中。

如果当前请求为AJAX 请求， 发送一个 `Location` 头不会自动使浏览器跳转，为解决这个问题， [yii\web\Response::redirect()](https://www.yiichina.com/doc/api/2.0/yii-web-response#redirect()-detail) 方法设置一个值为要跳转的URL的`X-Redirect` 头， 在客户端可编写JavaScript 代码读取该头部值然后让浏览器跳转对应的URL。

#### 发送文件

和浏览器跳转类似，文件发送是另一个依赖指定HTTP头的功能， Yii提供方法集合来支持各种文件发送需求，它们对HTTP头都有内置的支持。

这些方法都将响应对象作为返回值，如果要发送的文件非常大，应考虑使用 [yii\web\Response::sendStreamAsFile()](https://www.yiichina.com/doc/api/2.0/yii-web-response#sendStreamAsFile()-detail) 因为它更节约内存， 以下示例显示在控制器操作中如何发送文件：

```php
public function actionDownload()
{
    return \Yii::$app->response->sendFile('path/to/file.txt');
}
```

如果不是在操作方法中调用文件发送方法，在后面还应调用[yii\web\Response::send()](https://www.yiichina.com/doc/api/2.0/yii-web-response#send()-detail) 没有其他内容追加到响应中。

```php
\Yii::$app->response->sendFile('path/to/file.txt')->send();
```

一些浏览器提供特殊的名为*X-Sendfile*的文件发送功能， 原理为将请求跳转到服务器上的文件， Web应用可在服务器发送文件前结束，为使用该功能， 可调用[yii\web\Response::xSendFile()](https://www.yiichina.com/doc/api/2.0/yii-web-response#xSendFile()-detail)， 如下简要列出一些常用Web服务器如何启用`X-Sendfile` 功能：

- Apache: [X-Sendfile](http://tn123.org/mod_xsendfile)
- Lighttpd v1.4: [X-LIGHTTPD-send-file](http://redmine.lighttpd.net/projects/lighttpd/wiki/X-LIGHTTPD-send-file)
- Lighttpd v1.5: [X-Sendfile](http://redmine.lighttpd.net/projects/lighttpd/wiki/X-LIGHTTPD-send-file)
- Nginx: [X-Accel-Redirect](http://wiki.nginx.org/XSendfile)
- Cherokee: [X-Sendfile and X-Accel-Redirect](http://www.cherokee-project.com/doc/other_goodies.html#x-sendfile)

#### 发送响应

在[yii\web\Response::send()](https://www.yiichina.com/doc/api/2.0/yii-web-response#send()-detail) 方法调用前响应中的内容不会发送给用户， 该方法默认在[yii\base\Application::run()](https://www.yiichina.com/doc/api/2.0/yii-base-application#run()-detail) 结尾自动调用，尽管如此，可以明确调用该方法强制立即发送响应。

[yii\web\Response::send()](https://www.yiichina.com/doc/api/2.0/yii-web-response#send()-detail) 方法使用以下步骤来发送响应：

1. 触发 [yii\web\Response::EVENT_BEFORE_SEND](https://www.yiichina.com/doc/api/2.0/yii-web-response#EVENT_BEFORE_SEND-detail) 事件.
2. 调用 [yii\web\Response::prepare()](https://www.yiichina.com/doc/api/2.0/yii-web-response#prepare()-detail) 来格式化 [response data](https://www.yiichina.com/doc/api/2.0/yii-web-response#$data-detail) 为[response content](https://www.yiichina.com/doc/api/2.0/yii-web-response#$content-detail).
3. 触发 [yii\web\Response::EVENT_AFTER_PREPARE](https://www.yiichina.com/doc/api/2.0/yii-web-response#EVENT_AFTER_PREPARE-detail) 事件.
4. 调用 [yii\web\Response::sendHeaders()](https://www.yiichina.com/doc/api/2.0/yii-web-response#sendHeaders()-detail) 来发送注册的HTTP头
5. 调用 [yii\web\Response::sendContent()](https://www.yiichina.com/doc/api/2.0/yii-web-response#sendContent()-detail) 来发送响应主体内容
6. 触发 [yii\web\Response::EVENT_AFTER_SEND](https://www.yiichina.com/doc/api/2.0/yii-web-response#EVENT_AFTER_SEND-detail) 事件.

一旦[yii\web\Response::send()](https://www.yiichina.com/doc/api/2.0/yii-web-response#send()-detail) 方法被执行后，其他地方调用该方法会被忽略， 这意味着一旦响应发出后，就不能再追加其他内容。

如你所见[yii\web\Response::send()](https://www.yiichina.com/doc/api/2.0/yii-web-response#send()-detail) 触发了几个实用的事件， 通过响应这些事件可调整或包装响应。

### Session and Cookies

Sessions and cookies允许数据在多次请求中保持，可以分别使用全局变量\$_SESSION和\$_COOKIE来访问，yii将session和cookie封装成对象并增加一些功能，可通过面向对象访问它们。

#### Session

和request、response类型，默认可通过为yii\web\Session实例的session组件来访问sessions。

##### 开启和关闭sessions

```php
$session = Yii::$app->session;
if ($session->isActive) //检查是否开启
$session->open();
$session->close();
$session->destroy(); //销毁session中所有注册的数据
```

##### 访问session数据

```php
$session = Yii::$app->session;
//get
$language = $session->get('language');
$language = $session['language'];
$language = isset($_SESSION['language']) ? $_SESSION['language'] : '';
//set
$session->set('language', 'en-US');
$session['language'] = 'en-US';
$_SESSION['language'] = 'en-US';
//delete
$session->remove('language');
unset($session['language']);
unset($_SESSION['language']);
// 检查session变量是否已存在，以下用法是相同的：
if ($session->has('language')) ...
if (isset($session['language'])) ...
if (isset($_SESSION['language'])) ...

// 遍历所有session变量，以下用法是相同的：
foreach ($session as $name => $value) ...
foreach ($_SESSION as $name => $value) ...
```

当session数据为数组时，session组件会限制你直接修改数据中的单元项，

```php
$session = Yii::$app->session;

// 如下代码不会生效
$session['captcha']['number'] = 5;
$session['captcha']['lifetime'] = 3600;

// 如下代码会生效：
$session['captcha'] = [
    'number' => 5,
    'lifetime' => 3600,
];

// 如下代码也会生效：
echo $session['captcha']['lifetime'];
```

##### 自定义session存储

[yii\web\Session](https://www.yiichina.com/doc/api/2.0/yii-web-session) 类默认存储 session 数据为文件到服务器上， Yii 提供以下 session 类实现不同的 session 存储方式：

- [yii\web\DbSession](https://www.yiichina.com/doc/api/2.0/yii-web-dbsession)：存储 session 数据在数据表中
- [yii\web\CacheSession](https://www.yiichina.com/doc/api/2.0/yii-web-cachesession)：存储 session 数据到缓存中，缓存和配置中的[缓存组件](https://www.yiichina.com/doc/guide/2.0/caching-data#cache-components)相关
- yii\redis\Session：存储 session 数据到以 [redis](http://redis.io/) 作为存储媒介中
- yii\mongodb\Session：存储 session 数据到 [MongoDB](http://www.mongodb.org/)。

所有这些session类支持相同的API方法集，因此， 切换到不同的session存储介质不需要修改项目使用session的代码。

#### cookies

当前请求的cookie信息可通过如下代码获取：

```php
// 从 "request" 组件中获取 cookie 集合(yii\web\CookieCollection)
$cookies = Yii::$app->request->cookies;

// 获取名为 "language" cookie 的值，如果不存在，返回默认值 "en"
$language = $cookies->getValue('language', 'en');

// 另一种方式获取名为 "language" cookie 的值
if (($cookie = $cookies->get('language')) !== null) {
    $language = $cookie->value;
}

// 可将 $cookies 当作数组使用
if (isset($cookies['language'])) {
    $language = $cookies['language']->value;
}

// 判断是否存在名为"language" 的 cookie
if ($cookies->has('language')) ...
if (isset($cookies['language'])) ...
```

##### 发送 Cookies

可使用如下代码发送 cookie 到终端用户：

```php
// 从 "response" 组件中获取 cookie 集合(yii\web\CookieCollection)
$cookies = Yii::$app->response->cookies;

// 在要发送的响应中添加一个新的 cookie
$cookies->add(new \yii\web\Cookie([
    'name' => 'language',
    'value' => 'zh-CN',
]));

// 删除一个 cookie
$cookies->remove('language');
// 等同于以下删除代码
unset($cookies['language']);
```

除了上述例子定义的 [name](https://www.yiichina.com/doc/api/2.0/yii-web-cookie#$name-detail) 和 [value](https://www.yiichina.com/doc/api/2.0/yii-web-cookie#$value-detail) 属性 [yii\web\Cookie](https://www.yiichina.com/doc/api/2.0/yii-web-cookie) 类也定义了其他属性来实现cookie的各种信息，如 [domain](https://www.yiichina.com/doc/api/2.0/yii-web-cookie#$domain-detail)，[expire](https://www.yiichina.com/doc/api/2.0/yii-web-cookie#$expire-detail) 可配置这些属性到 cookie 中并添加到响应的 cookie 集合中。

> **注意：** 为安全起见 [yii\web\Cookie::$httpOnly](https://www.yiichina.com/doc/api/2.0/yii-web-cookie#$httpOnly-detail) 被设置为 true， 这可减少客户端脚本访问受保护 cookie（如果浏览器支持）的风险， 更多详情可阅读 [httpOnly wiki article](https://www.owasp.org/index.php/HttpOnly)。

##### Cookie验证

在上两节中，当通过 `request` 和 `response` 组件读取和发送 cookie 时， 你会喜欢扩展的 cookie 验证的保障安全功能，它能 使 cookie 不被客户端修改。该功能通过给每个cookie签发一个哈希字符串来告知服务端 cookie 是否在客户端被修改， 如果被修改，通过 `request` 组件的 [cookie collection](https://www.yiichina.com/doc/api/2.0/yii-web-request#$cookies-detail) cookie 集合访问不到该 cookie。

> **注意：** Cookie验证只保护 cookie 值被修改，如果一个 cookie 验证失败， 仍然可以通过 `$_COOKIE` 来访问该 cookie， 因为这是第三方库对未通过 cookie 验证自定义的操作方式。

Cookie 验证默认启用，可以设置 [yii\web\Request::$enableCookieValidation](https://www.yiichina.com/doc/api/2.0/yii-web-request#$enableCookieValidation-detail) 属性为 false 来禁用它， 尽管如此，我们强烈建议启用它。

> **注意：** 直接通过 `$_COOKIE` 和 `setcookie()` 读取和发送的 Cookie 不会被验证。

当使用 cookie 验证时，必须指定 [yii\web\Request::$cookieValidationKey](https://www.yiichina.com/doc/api/2.0/yii-web-request#$cookieValidationKey-detail)，它是用来生成上述的哈希值， 可通过在应用配置中配置 `request` 组件。

```php
return [
    'components' => [
        'request' => [
            'cookieValidationKey' => 'fill in a secret key here',
        ],
    ],
];
```
#### 错误处理

Yii内置了一个error handler错误处理器，它使错误更方便，yii错误处理器做一下工作提升错误处理效果

- 所有非致命PHP错误会转换可获取异常
- 异常和致命的PHP错误会被显示，在调试模式会显示详细的函数调用栈和源代码行数
- 支持使用专用的控制器操作来显示错误
- 支持不同的错误响应格式

错误处理器默认开启，可通过入口脚本中定义常量YII_ENABLE_ERROR_HANDLER来禁用。

##### 使用错误处理器

error handler注册成一个名称为errorHandler组件，可以在应用配置中配置它类似：

```php
return [
    'component' => [
        'errorHandler' => [
            'maxSourceLines' => 20, //异常页面最多显示20条源代码
        ],
    ],
];
```

##### 自定义错误显示

error handler错误处理器根据长了YII_DEBUG的值来调整错误显示，当YII_DEBUG为true，错误处理器会显示异常以及详细的函数调用栈和源代码来帮助调试。

> **信息：** 如果异常是继承yii\base\UserException， 不管`YII_DEBUG`为何值，函数调用栈信息都不会显示， 这是因为这种错误会被认为是用户产生的错误，开发人员不需要去修正。

##### 使用错误动作

配置errorHandler组件中的errorAction属性，使用路由到一个操作上

```php
return [
    'components' => [
        'errorHandler' => [
            'errorAction' => 'site/error',
        ],
    ]
];
```

Site/error动作

##### 自定义错误格式

错误处理器根据响应设置的格式来显示错误，可在应用配置中响应`response`组件的 `beforeSend`事件来自定义错误响应格式。

```php
return [
    // ...
    'components' => [
        'response' => [
            'class' => 'yii\web\Response',
            'on beforeSend' => function ($event) {
                $response = $event->sender;
                if ($response->data !== null) {
                    $response->data = [
                        'success' => $response->isSuccessful,
                        'data' => $response->data,
                    ];
                    $response->statusCode = 200;
                }
            },
        ],
    ],
];
```

#### 日志

使用yii日志框架涉及：

- 在你代码中各个地方记录log messages；
- 在应用配置里通过配置log target来过滤和导出日志消息
- 检查由不同的目标导出的已过滤的日志消息

##### 日志消息

记录日志消息就跟调用下面的日志方法一样简单：

- [Yii::trace()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#trace()-detail)：记录一条消息去跟踪一段代码是怎样运行的。这主要在开发的时候使用。
- [Yii::info()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#info()-detail)：记录一条消息来传达一些有用的信息。
- [Yii::warning()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#warning()-detail)：记录一个警告消息用来指示一些已经发生的意外。
- [Yii::error()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#error()-detail)：记录一个致命的错误，这个错误应该尽快被检查。

##### 日志目标

一个日志目标是一个 [yii\log\Target](https://www.yiichina.com/doc/api/2.0/yii-log-target) 类或者它的子类的实例。 它将通过他们的严重层级和类别来过滤日志消息，然后将它们导出到一些媒介中。 例如，一个 [database target](https://www.yiichina.com/doc/api/2.0/yii-log-dbtarget) 目标导出已经过滤的日志消息到一个数据的表里面， 而一个 [email target](https://www.yiichina.com/doc/api/2.0/yii-log-emailtarget)目标将日志消息导出到指定的邮箱地址里。

```php
return [
    // the "log" component must be loaded during bootstrapping time
    'bootstrap' => ['log'],
    
    'components' => [
        'log' => [
            'targets' => [
                [
                    'class' => 'yii\log\DbTarget',
                    'levels' => ['error', 'warning'],
                ],
                [
                    'class' => 'yii\log\EmailTarget',
                    'levels' => ['error'],
                    'categories' => ['yii\db\*'],
                    'message' => [
                       'from' => ['log@example.com'],
                       'to' => ['admin@example.com', 'developer@example.com'],
                       'subject' => 'Database errors at example.com',
                    ],
                ],
            ],
        ],
    ],
];

```

>**注意：** `log` 组件必须在 [bootstrapping](https://www.yiichina.com/doc/guide/2.0/runtime-bootstrapping) 期间就被加载，以便于它能够及时调度日志消息到目标里。 这是为什么在上面的代码中，它被列在 `bootstrap` 数组中的原因。

- [yii\log\DbTarget](https://www.yiichina.com/doc/api/2.0/yii-log-dbtarget)：在数据库表里存储日志消息。
- [yii\log\EmailTarget](https://www.yiichina.com/doc/api/2.0/yii-log-emailtarget)：发送日志消息到预先指定的邮箱地址。
- [yii\log\FileTarget](https://www.yiichina.com/doc/api/2.0/yii-log-filetarget)：保存日志消息到文件中.
- [yii\log\SyslogTarget](https://www.yiichina.com/doc/api/2.0/yii-log-syslogtarget)：通过调用PHP函数 `syslog()` 将日志消息保存到系统日志里。

 ##### 消息过滤

对于每一个日志目标，你可以配置它的 [levels](https://www.yiichina.com/doc/api/2.0/yii-log-target#$levels-detail) 和 [categories](https://www.yiichina.com/doc/api/2.0/yii-log-target#$categories-detail) 属性来指定哪个消息的严重程度和分类目标应该处理。

level属性：

- `error`：相应的消息通过 [Yii::error()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#error()-detail) 被记录。
- `warning`：相应的消息通过 [Yii::warning()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#warning()-detail) 被记录。
- `info`：相应的消息通过 [Yii::info()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#info()-detail) 被记录。
- `trace`：相应的消息通过 [Yii::trace()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#trace()-detail) 被记录。
- `profile`：相应的消息通过 [Yii::beginProfile()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#beginProfile()-detail) 和 [Yii::endProfile()](https://www.yiichina.com/doc/api/2.0/yii-baseyii#endProfile()-detail) 被记录。更多细节将在[Profiling](https://www.yiichina.com/doc/guide/2.0/runtime-logging#performance-profiling) 分段解释。

在下面的目标配置中指明了目标应该只处理错误和警告消息，当分类的名称匹配 `yii\db\*` 或者是 `yii\web\HttpException:*` 的时候， 但是除了 `yii\web\HttpException:404`。

```php
[
    'class' => 'yii\log\FileTarget',
    'levels' => ['error', 'warning'],
    'categories' => [
        'yii\db\*',
        'yii\web\HttpException:*',
    ],
    'except' => [
        'yii\web\HttpException:404',
    ],
]
```

##### 消息格式化

通过配置 [yii\log\Target::$prefix](https://www.yiichina.com/doc/api/2.0/yii-log-target#$prefix-detail) 的属性来自定义格式，这个属性是一个PHP可调用体返回的自定义消息前缀。

```php
[
    'class' => 'yii\log\FileTarget',
    'prefix' => function ($message) {
        $user = Yii::$app->has('user', true) ? Yii::$app->get('user') : null;
        $userID = $user ? $user->getId(false) : '-';
        return "[$userID]";
    }
]
```

##### 消息跟踪级别

在开发的时候，通常希望看到每个日志消息来自哪里。这个是能够被实现的，通过配置 `log` 组件的 [traceLevel](https://www.yiichina.com/doc/api/2.0/yii-log-dispatcher#$traceLevel-detail) 属性， 就像下面这样：

```php
return [
    'bootstrap' => ['log'],
    'components' => [
        'log' => [
            'traceLevel' => YII_DEBUG ? 3 : 0,
            'targets' => [...],
        ],
    ],
];
```

上面的应用配置设置了 [traceLevel](https://www.yiichina.com/doc/api/2.0/yii-log-dispatcher#$traceLevel-detail) 的层级，假如 `YII_DEBUG` 开启则是3，否则是0。 这意味着，假如 `YII_DEBUG` 开启，每个日志消息在日志消息被记录的时候， 将被追加最多3个调用堆栈层级；假如 `YII_DEBUG` 关闭， 那么将没有调用堆栈信息被包含。

> **注意：** 获得调用堆栈信息并不是不重要。因此， 你应该只在开发或者调试一个应用的时候使用这个特性。

##### 切换日志目标

你可以通过配置 [enabled](https://www.yiichina.com/doc/api/2.0/yii-log-target#$enabled-detail) 属性来开启或者禁用日志目标。 你可以通过日志目标配置去做，或者是在你的代码中放入下面的PHP申明：

```
Yii::$app->log->targets['file']->enabled = false;
```

上面的代码要求您将目标命名为 `file`，像下面展示的那样， 在 `targets` 数组中使用使用字符串键：

```php
return [
    'bootstrap' => ['log'],
    'components' => [
        'log' => [
            'targets' => [
                'file' => [
                    'class' => 'yii\log\FileTarget',
                ],
                'db' => [
                    'class' => 'yii\log\DbTarget',
                ],
            ],
        ],
    ],
];
```

##### 创建新的目标

创建一个新的日志目标类非常地简单。你主要需要实现 [yii\log\Target::export()](https://www.yiichina.com/doc/api/2.0/yii-log-target#export()-detail) 方法来发送 [yii\log\Target::$messages](https://www.yiichina.com/doc/api/2.0/yii-log-target#$messages-detail) 数组的 内容到一个指定的媒体中。你可以调用 [yii\log\Target::formatMessage()](https://www.yiichina.com/doc/api/2.0/yii-log-target#formatMessage()-detail) 方法去格式化每个消息。 

##### 性能分析

性能分析是一个特殊的消息记录类型，它通常用在测量某段代码块的时间， 并且找出性能瓶颈是什么。举个例子，[yii\db\Command](https://www.yiichina.com/doc/api/2.0/yii-db-command) 类 使用性能分析找出每个数据库查询的时间。

为了使用性能分析，首先确定需要进行分析的代码块。 然后像下面这样围住每个代码块：

```php
\Yii::beginProfile('myBenchmark');

...code block being profiled...

\Yii::endProfile('myBenchmark');
```

这里的 `myBenchmark` 代表一个唯一标记来标识一个代码块。之后当你检查分析结果的时候， 你将使用这个标记来定位对应的代码块所花费的时间。

对于确保 `beginProfile` 和 `endProfile` 对能够正确地嵌套，这是很重要的。 例如，

```php
\Yii::beginProfile('block1');

    // some code to be profiled

    \Yii::beginProfile('block2');
        // some other code to be profiled
    \Yii::endProfile('block2');

\Yii::endProfile('block1');
```

假如你漏掉 `\Yii::endProfile('block1')` 或者切换了 `\Yii::endProfile('block1')` 和 `\Yii::endProfile('block2')` 的 顺序，那么性能分析将不会工作。

对于每个被分析的代码块，一个带有严重程度 `profile` 的日志消息被记录。 你可以配置一个 [log target](https://www.yiichina.com/doc/guide/2.0/runtime-logging#log-targets) 去收集这些 消息，并且导出他们。[Yii debugger](https://www.yiichina.com/doc/guide/2.0/tool-debugger) 有一个内建的性能分析面板能够展示分析结果。

## 关键概念

### 事件

要让一个对象有事件能力，该类需要继承yii\base\Component。

#### 事件处理器

事件处理器是一个PHP回调函数，当它所附加到的事件被触发时，他就会执行。

- 字符串形式指定的PHP全局函数，如`trim()`
- 对象名和方法名数组形式指定的对象方法，如`[$object, $method]`
- 类名和方法名数组形式指定的静态类方法，如`[$class, $method]`
- 匿名函数，如`function ($event) {}`

```php
$foo = new Foo;

// 处理器是全局函数
$foo->on(Foo::EVENT_HELLO, 'function_name');

// 处理器是对象方法
$foo->on(Foo::EVENT_HELLO, [$object, 'methodName']);

// 处理器是静态类方法
$foo->on(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

// 处理器是匿名函数
$foo->on(Foo::EVENT_HELLO, function ($event) {
    //事件处理逻辑
});
```

附加事件处理器可以提供额外的数据作为`yii\base\Component::on()`方法的第三个参数，数据在事件被触发和处理器被调用时能被处理器使用。

```php
// 当事件被触发时以下代码显示 "abc"
// 因为 $event->data 包括被传递到 "on" 方法的数据
$foo->on(Foo::EVENT_HELLO, 'function_name', 'abc');

function function_name($event) {
    echo $event->data;
}
```

#### 触发事件

事件通过调用 [yii\base\Component::trigger()](https://www.yiichina.com/doc/api/2.0/yii-base-component#trigger()-detail) 方法触发，此方法须传递*事件名*， 还可以传递一个事件对象，用来传递参数到事件处理器

```php
namespace app\components;

use yii\base\Component;
use yii\base\Event;

class Foo extends Component
{
    const EVENT_HELLO = 'hello';

    public function bar()
    {
        $this->trigger(self::EVENT_HELLO);
    }
}
```

以上代码当调用 `bar()` ，它将触发名为 `hello` 的事件。

有时想要在触发事件时同时传递一些额外信息到事件处理器。 例如，邮件程序要传递消息信息到 `messageSent` 事件的处理器以便处理器了解哪些消息被发送了。 为此，可以提供一个事件对象作为 [yii\base\Component::trigger()](https://www.yiichina.com/doc/api/2.0/yii-base-component#trigger()-detail) 方法的第二个参数。 这个事件对象必须是 [yii\base\Event](https://www.yiichina.com/doc/api/2.0/yii-base-event) 类或其子类的实例。 如：

```php
namespace app\components;

use yii\base\Component;
use yii\base\Event;

class MessageEvent extends Event
{
    public $message;
}

class Mailer extends Component
{
    const EVENT_MESSAGE_SENT = 'messageSent';

    public function send($message)
    {
        // ...发送 $message 的逻辑...

        $event = new MessageEvent;
        $event->message = $message;
        $this->trigger(self::EVENT_MESSAGE_SENT, $event);
    }
}
```

当 [yii\base\Component::trigger()](https://www.yiichina.com/doc/api/2.0/yii-base-component#trigger()-detail) 方法被调用时， 它将调用所有附加到命名事件（trigger 方法第一个参数）的事件处理器。

#### 移除事件处理器

调用`yii\baseComponent::off()`方法

```php
// 处理器是全局函数
$foo->off(Foo::EVENT_HELLO, 'function_name');

// 处理器是对象方法
$foo->off(Foo::EVENT_HELLO, [$object, 'methodName']);

// 处理器是静态类方法
$foo->off(Foo::EVENT_HELLO, ['app\components\Bar', 'methodName']);

// 处理器是匿名函数
$foo->off(Foo::EVENT_HELLO, $anonymousFunction);
```

移除事件的全部处理器，只需要`$foo->off(Foo::EVENT_HELLO);`.

#### 类级别的事件处理器

要实现一个类的所有实例而不是一个指定的实例都响应一个被触发的事件。通过调用静态方法`yii\base\Event::on()`在类级别的附加处理器

```php
use Yii;
use yii\base\Event;
use yii\db\ActiveRecord;

Event::on(ActiveRecord::className(), ActiveRecord::EVENT_AFTER_INSERT, function ($event) {
    Yii::debug(get_class($event->sender) . ' is inserted');
});
```

每当 [ActiveRecord](https://www.yiichina.com/doc/api/2.0/yii-db-baseactiverecord) 或其子类的实例触发 [EVENT_AFTER_INSERT](https://www.yiichina.com/doc/api/2.0/yii-db-baseactiverecord#EVENT_AFTER_INSERT-detail) 事件时， 这个事件处理器都会执行。在这个处理器中，可以通过 `$event->sender` 获取触发事件的对象。

可调用`yii\base\Event::trigger()`来触发一个类级别事件。

#### 接口事件

为特殊的事件创建一个独立的接口，然后在需要的类中实现它。

首先创建一个接口

```php
namespace app\interfaces;

interface DanceEventInterface
{
    const EVENT_DANCE = 'dance';
}
```

然后在两个类中实现接口类

```php
class Dog extends Component implements DanceEventInterface
{
    public function meetBuddy()
    {
        echo "Woof!";
        $this->trigger(DanceEventInterface::EVENT_DANCE);
    }
}

class Developer extends Component implements DanceEventInterface
{
    public function testsPassed()
    {
        echo "Yay!";
        $this->trigger(DanceEventInterface::EVENT_DANCE);
    }
}
```

要处理由这些类触发的 `EVENT_DANCE` ，调用 [Event::on()](https://www.yiichina.com/doc/api/2.0/yii-base-event#on()-detail) 并将接口类名作为第一个参数:

```php
Event::on('app\interfaces\DanceEventInterface', DanceEventInterface::EVENT_DANCE, function ($event) {
    Yii::trace(get_class($event->sender) . ' just danced'); // Will log that Dog or Developer danced
});
```

你可以在这些类中触发这个事件：

```php
// trigger event for Dog class
Event::trigger(Dog::className(), DanceEventInterface::EVENT_DANCE);

// trigger event for Developer class
Event::trigger(Developer::className(), DanceEventInterface::EVENT_DANCE);

/ 不会生效。实现此接口的类不会触发事件。
Event::trigger('app\interfaces\DanceEventInterface', DanceEventInterface::EVENT_DANCE);
```

#### 全局事件

所谓*全局事件*实际上是一个基于以上叙述的事件机制的戏法。它需要一个全局可访问的单例， 如[应用](https://www.yiichina.com/doc/guide/2.0/structure-applications)实例。

事件触发者不调用其自身的 `trigger()` 方法，而是调用单例的 `trigger()` 方法来触发全局事件。 类似地，事件处理器被附加到单例的事件。如：

```php
use Yii;
use yii\base\Event;
use app\components\Foo;

Yii::$app->on('bar', function ($event) {
    echo get_class($event->sender);  // 显示 "app\components\Foo"
});

Yii::$app->trigger('bar', new Event(['sender' => new Foo]));
```

全局事件的一个好处是当附加处理器到一个对象要触发的事件时， 不需要产生该对象。相反，处理器附加和事件触发都通过单例 （如应用实例）完成。

#### 通配符事件

可以为多个匹配通配符模式的事件设置事件处理程序。

### 行为

行为是`yii\base\Behavior`或其子类的实例。可以无须改变继承关系即可增强一个已有组件类功能。当行为附加到组件后，它将注入它的方法和属性到组件，然后可以像访问组件内定位的方法和属性一样访问它们。此外，行为通过组件能响应被触发的[事件](https://www.yiichina.com/doc/guide/2.0/basic-events)，从而自定义或调整组件正常执行的代码。

例如有两个控制器和一个GoodsController，一个OrderController，它们都接受请求，返回数据给客户，但是返回不同的形式，json活着xml。由此，创建一个返回数据行为扩展这两个控制器。

在common目录下，并创建ReturnBehavior.php，

```php
<?php
 
namespace app\common;
 
use YII;
use yii\base\Behavior;
use yii\web\Controller;
use yii\web\Response;
 
//必须继承自yii\base\Behavior
class ReturnBehavior extends Behavior
{
 
    //返回类型，通过控制器里的behaviors()配置参数获取值
    public $return_type = '';
 
    //让行为响应组件的事件触发
    public function events()
    {
        return [
            //控制器方法执行后触发事件，调用returnData函数
            Controller::EVENT_AFTER_ACTION => 'returnData',
        ];
    }
 
    //返回数据
    public function returnData()
    {
        switch ($this->return_type) {
            case 'json':
                YII::$app->response->format = Response::FORMAT_JSON;
                break;
            case 'xml':
                YII::$app->response->format = Response::FORMAT_XML;
                break;
            case 'html':
                YII::$app->response->format = Response::FORMAT_HTML;
                break;
            default :
                break;
        }
    }
 
    //定义方法
    public function test() {
        echo 'returnBehavior test ...';
    }
}
```

GoodsController.php

```php
<?php
 
namespace app\controllers;
 
use YII;
use app\common\ReturnBehavior;
use yii\web\Controller;
 
//想要使用行为，必须是component或是其子类
//yii\web\Controller继承自component，所以可以使用
class GoodsController extends Controller
{
 
    //配置控制器需要使用的行为
    public function behaviors()
    {
        return [
            'returnBehavior' => [
                'class' => ReturnBehavior::className(),
                'return_type' => 'json',
            ],
        ];
    }
 
    //获取商品列表
    public function actionGetGoodsList()
    {
        return [
            ['id' => 1, 'name' => '商品1'],
            ['id' => 2, 'name' => '商品2'],
        ];
    }
 
    public function actionIndex()
    {
        //控制器调用行为中的方法
        $this->getBehavior('returnBehavior')->test();
        //注意这里，因为使用了行为，方法执行后会设置返回内容为xml，我们重新设置为html
        $this->getBehavior('returnBehavior')->return_type = 'html';
    }
}
```

OrderController.php

```php
<?php
 
namespace app\controllers;
 
use YII;
use app\common\ReturnBehavior;
use yii\web\Controller;
 
//想要使用行为，必须是component或是其子类
//yii\web\Controller继承自component，所以可以使用
class OrderController extends Controller
{
    //配置控制器需要使用的行为
    public function behaviors()
    {
        return [
            'returnBehavior' => [
                'class' => ReturnBehavior::className(),
                'return_type' => 'xml',
            ],
        ];
    }
 
    //获取商品列表
    public function actionGetOrderList()
    {
        return [
            ['id' => 1, 'name' => '订单1'],
            ['id' => 2, 'name' => '订单2'],
        ];
    }
 
    public function actionIndex()
    {
        //控制器调用行为中的方法
        $this->getBehavior('returnBehavior')->test();
        //注意这里，因为使用了行为，方法执行后会设置返回内容为xml，我们重新设置为html
        $this->getBehavior('returnBehavior')->return_type = 'html';
    }
}
```

### 配置

配置通常包含被创建对象的类名和一组将要复制给对象属性的初始值。

### 别名

别名用来表示文件路径和URL，这样就避免了在代码中硬编码一些绝对路径和URL。一个别名必须以@开头，以区别传统的文件路径和URL。

#### 定义别名

可以通过调用`Yii::setAlias()`和component中配置alias属性。

#### 解析别名

通过`Yii::getAlias()`命令解析。

#### 预定义别名

- `@yii`，`BaseYii.php` 文件所在的目录（也被称为框架安装目录）。
- `@app`，当前运行的应用 [根路径（base path）](https://www.yiichina.com/doc/api/2.0/yii-base-module#$basePath-detail)。
- `@runtime`，当前运行的应用的 [运行环境（runtime）路径](https://www.yiichina.com/doc/api/2.0/yii-base-application#$runtimePath-detail)。默认为 `@app/runtime`。
- `@webroot`，当前运行的Web应用程序的Web根目录。 它是根据包含 [入口脚本](https://www.yiichina.com/doc/guide/2.0/structure-entry-scripts) 的目录确定的。
- `@web`，当前运行的Web应用程序的 base URL。它的值与 [yii\web\Request::$baseUrl](https://www.yiichina.com/doc/api/2.0/yii-web-request#$baseUrl-detail) 相同。
- `@vendor`，[Composer vendor 目录](https://www.yiichina.com/doc/api/2.0/yii-base-application#$vendorPath-detail)。
- `@bower`，包含 [bower 包](http://bower.io/) 的根目录。默认为 `@vendor/bower`。
- `@npm`，包含 [npm 包](https://www.npmjs.org/) 的根目录。默认为 `@vendor/npm`。

### 类自动加载

Yii依靠类自动加载机制来定位和包含所需文件

#### 类映射表

Yii类自动加载器支持类映射表功能，该功能会建立一个从类的名字到类文件路径的映射。当自动加载器加载一个文件时，他首先检查映射表里有没有该类。如果有，对应的文件路径就直接加载了，省掉了进一步检查。

```php
Yii::$classMap['far\bar\MyClass'] = 'path/to/MyClass.php'; //向映射表添加类
```

#### 用其他自动加载器

Yii完全支持Composer管理依赖包。

```php
//安装Composer的自动加载器
require __DIR__ . '/../vendor/autoload.php' 
//安装Yii的自动加载器
require __DIR__ . '/../vendor/yiisoft/yii2/Yii/php'
```

### 服务定位器

服务定位器是一个了解如何提供各种应用所需的服务的对象。在服务定位器中，每个组件都只有一个单独的实例，并通过ID唯一地标示。

最常用的服务定位器是application对象，通过Yii::\$app访问。它所提供的服务被称为application components，比如：request组件。

要使用服务定位器，第一步是要注册相关组件。组件可以通过`yii\di\ServiceLocator::set()`方法进行注册。

```php
use yii\di\ServiceLocator;
use yii\caching\FileCache;

$locator = new ServiceLocator;

// 通过一个可用于创建该组件的类名，注册 "cache" （缓存）组件。
$locator->set('cache', 'yii\caching\ApcCache');

// 通过一个可用于创建该组件的配置数组，注册 "db" （数据库）组件。
$locator->set('db', [
    'class' => 'yii\db\Connection',
    'dsn' => 'mysql:host=localhost;dbname=demo',
    'username' => 'root',
    'password' => '',
]);

```

组件被注册成功，通过ID访问

```php
$cache = $locator->get('cache');
$cache = $locator->cache;
```

#### 遍历树

模块允许任意嵌套；Yii应用程序本质上是一个模块树。由于这些模块中的每一个都是服务定位器，所以子模块有权限访问其父模块。 这允许模块使用 `$this->get('db')` 而不是引用根服务定位器 `Yii::$app->get('db')`。 增加的好处是开发人员可以覆盖模块中的配置。

### 依赖注入容器

依赖注入容器就是一个对象，他知道怎么初始化并配置依赖的所有对象。

#### 依赖注入

Yii通过`yii\di\Container`类提供DI容器特性，所支持的依赖注入：

- 构造方法注入
- 方法注入
- Setter和属性注入
- PHP回调注入

##### 构造方法注入

在参数类型提示的帮助下，DI 容器实现了构造方法注入。当容器被用于创建一个新对象时， 类型提示会告诉它要依赖什么类或接口。 容器会尝试获取它所依赖的类或接口的实例， 然后通过构造器将其注入新的对象。

##### 方法注入

通常，类的依赖关系传递给构造函数，并且在整个生命周期中都可以在类内部使用。 通过方法注入，可以提供仅由类的单个方法需要的依赖关系， 并将其传递给构造函数可能不可行，或者可能会在大多数用例中导致太多开销。

```php
class MyClass extends \yii\base\Component
{
    public function __construct(/*Some lightweight dependencies here*/, $config = [])
    {
        // ...
    }

    public function doSomething($param1, \my\heavy\Dependency $something)
    {
        // do something with $something
    }
}
```

你可以自己过一个实例 `\my\heavy\Dependency` 调用这个方法或使用 [yii\di\Container::invoke()](https://www.yiichina.com/doc/api/2.0/yii-di-container#invoke()-detail) 如下：

```php
$obj = new MyClass(/*...*/);
Yii::$container->invoke([$obj, 'doSomething'], ['param1' => 42]); // $something will be provided by the DI container
```

##### setter和属性注入

Setter和属性注入是通过配置提供支持的。当注册一个依赖或创建一个新对象时。你可以提供一个配置，该配置会提供给容器用于通过相应的setter或属性注入依赖。

```php
use yii\base\BaseObject;

class Foo extends BaseObject
{
    public $bar;

    private $_qux;

    public function getQux()
    {
        return $this->_qux;
    }

    public function setQux(Qux $qux)
    {
        $this->_qux = $qux;
    }
}

$container->get('Foo', [], [
    'bar' => $container->get('Bar'),
    'qux' => $container->get('Qux'),
]);
```

>**信息：** [yii\di\Container::get()](https://www.yiichina.com/doc/api/2.0/yii-di-container#get()-detail) 方法将其第三个参数作为配置数组应用于正在创建的对象。 如果该类实现 [yii\base\Configurable](https://www.yiichina.com/doc/api/2.0/yii-base-configurable) 接口（例如 [yii\base\BaseObject](https://www.yiichina.com/doc/api/2.0/yii-base-baseobject)），则配置数组将作为最后一个参数传递给类构造函数； 否则，将在创建对象*后*应用该配置。

##### PHP回调注入

```php
$container->set('Foo', function () {
    $foo = new Foo(new Bar);
    // ... 其他初始化 ...
    return $foo;
});

$foo = $container->get('Foo');
```

#### 注册依赖关系

可以用`yii\di\Container::set()`注册依赖关系。注册会用到一个依赖关系名称和一个依赖关系的定义。依赖关系名称可以是一个类名，一个接口或一个别名。

```php
$container = new \yii\di\Container;

// 注册一个同类名一样的依赖关系，这个可以省略。
$container->set('yii\db\Connection');

// 注册一个接口
// 当一个类依赖这个接口时，
//相应的类会被初始化作为依赖对象。
$container->set('yii\mail\MailInterface', 'yii\swiftmailer\Mailer');

// 注册一个别名。
// 你可以使用 $container->get('foo') 创建一个 Connection 实例
$container->set('foo', 'yii\db\Connection');

// 通过配置注册一个类
// 通过 get() 初始化时，配置将会被使用。
$container->set('yii\db\Connection', [
    'dsn' => 'mysql:host=127.0.0.1;dbname=demo',
    'username' => 'root',
    'password' => '',
    'charset' => 'utf8',
]);

// 通过类的配置注册一个别名
// 这种情况下，需要通过一个 “class” 元素指定这个类
$container->set('db', [
    'class' => 'yii\db\Connection',
    'dsn' => 'mysql:host=127.0.0.1;dbname=demo',
    'username' => 'root',
    'password' => '',
    'charset' => 'utf8',
]);

// 注册一个 PHP 回调
// 每次调用 $container->get('db') 时，回调函数都会被执行。
$container->set('db', function ($container, $params, $config) {
    return new \yii\db\Connection($config);
});

// 注册一个组件实例
// $container->get('pageCache') 每次被调用时都会返回同一个实例。
$container->set('pageCache', new FileCache);
```

注册一个单例的依赖关系，`yii\di\Container::setSingleton()`

```php
$container->setSingleton('yii\db\Connection', [
    'dsn' => 'mysql:host=127.0.0.1;dbname=demo',
    'username' => 'root',
    'password' => '',
    'charset' => 'utf8',
]);
```

